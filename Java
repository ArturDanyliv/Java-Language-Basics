function(){
    "use strict";

    //define variables
    var items = document.querySelectorAll(".timeline li")

    //check if an element is in viewport
    function isElementInViewport(el){(a)
    var rect = el.getBoundingClientRect();
    return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <=
            (window.innerHeight || document.documentElement.clientHeight) &&
        rect.right <= (window.innerWidth || documentElement.
clientWidth)
    );
}
    function callbackFunc() {
        for(var i = 0; i < items.length; i++){
            if (isElementInViewport(items[i])){
                items[i].classList.add("in-view");
            }
        }
    }
// listen for events
window.addEventListener("load", callbackFunc);
window.addEventListener("resize", callbackFunc);
window.addEventListener("scroll", callbackFunc);


// Pionowa linia czasu
//Podczas próby przekazania opinii użytkownikom nie ma potrzeby prezentowania ich na górze tekstu. Lepiej jest przyciągnąć ich uwagę za pomocą efektów wizualnych. Timline pomaga w pokazaniu historii witryny/produktu w prostej i interaktywnej formie. It jest łatwiejszy i bardziej interesujący dla gościa.
//Na rysunku przedstawiono przykład implementacji pionowej linii czasu. Pamiętaj i używaj!


let user = {}; //user has no address
alert (user?.address?.street); // undefined (no error)

// Optymalną spójność
//Często będziesz stanąć w obliczu sytuacji, w której oczekiwany element łańcucha właściwości nie jest zdefiniowany lub ma wartość zerową. W takim przypadku skrypt języka Java wydaje błąd, ponieważ nie może uzyskać wartości. Optymalny przebieg pomoże pozbyć się tego błędu. Jeśli jedno z ogniw łańcucha jest puste lub nie zostało zdefiniowane, operator zamknie i zwróci niezdefiniowaną wartość.

private void printGuessStatistics(char candidate, int count) {
    String number;
    String verb;
    String pluralModifier;
    if (count == 0) {
       number = "no";
       verb = "are";
       pluralModifier = "s";
    } else if (count == 1) {
       number = "1";
       verb = "is";
       pluralModifier = "";
    } else {
       number = Integer.toString(count);
       verb = "are";
       pluralModifier = "s";
    }
    String guessMessage = String.format(
       "There %s %s %s%s", verb, number, candidate, pluralModifier);
    print(guessMessage);
 }
 
 /////
 public class GuessStatisticsMessage {
    private String number;
    private String verb;
    private String pluralModifier;
 
    public String make(char candidate, int count) {
       createPluralDependentMessageParts(count);
       return String.format(
          "There %s %s %s%s",
          verb, number, candidate, pluralModifier );
    }
 
    private void createPluralDependentMessageParts(int count) {
       if (count == 0) {
          thereAreNoLetters();
       } else if (count == 1) {
          thereIsOneLetter();
       } else {
          thereAreManyLetters(count);
       }
    }
 
    private void thereAreManyLetters(int count) {
       number = Integer.toString(count);
       verb = "are";
       pluralModifier = "s";
    }
 
    private void thereIsOneLetter() {
       number = "1";
       verb = "is";
       pluralModifier = "";
    }
 
    private void thereAreNoLetters() {
       number = "no";
       verb = "are";
       pluralModifier = "s";
    }
 }
 //////
  public static String testableHtml(
   PageData pageData,
   boolean includeSuiteSetup
 ) throws Exception {
   WikiPage wikiPage = pageData.getWikiPage();
   StringBuffer buffer = new StringBuffer();
   if (pageData.hasAttribute("Test")) {
     if (includeSuiteSetup) {
       WikiPage suiteSetup =
         PageCrawlerImpl.getInheritedPage(
                 SuiteResponder.SUITE_SETUP_NAME, wikiPage
         );
       if (suiteSetup != null) {
         WikiPagePath pagePath =
           suiteSetup.getPageCrawler().getFullPath(suiteSetup);
         String pagePathName = PathParser.render(pagePath);
         buffer.append("!include -setup .")
               .append(pagePathName)
               .append("\n");
       }
     }
     WikiPage setup =
       PageCrawlerImpl.getInheritedPage("SetUp", wikiPage);
     if (setup != null) {
       WikiPagePath setupPath =
         wikiPage.getPageCrawler().getFullPath(setup);
       String setupPathName = PathParser.render(setupPath);
       buffer.append("!include -setup .")
             .append(setupPathName)
             .append("\n");
     }
   }
   buffer.append(pageData.getContent());
   if (pageData.hasAttribute("Test")) {
     WikiPage teardown =
       PageCrawlerImpl.getInheritedPage("TearDown", wikiPage);
     if (teardown != null) {
       WikiPagePath tearDownPath =
         wikiPage.getPageCrawler().getFullPath(teardown);
       String tearDownPathName = PathParser.render(tearDownPath);
       buffer.append("\n")
             .append("!include -teardown .")
             .append(tearDownPathName)
             .append("\n");
     }
     if (includeSuiteSetup) {
       WikiPage suiteTeardown =
         PageCrawlerImpl.getInheritedPage(
                 SuiteResponder.SUITE_TEARDOWN_NAME,
                 wikiPage
         );
       if (suiteTeardown != null) {
         WikiPagePath pagePath =
           suiteTeardown.getPageCrawler().getFullPath (suiteTeardown);
         String pagePathName = PathParser.render(pagePath);
         buffer.append("!include -teardown .")
               .append(pagePathName)
               .append("\n");
       }
     }
   }
   pageData.setContent(buffer.toString());
   return pageData.getHtml();
 }
 //////
 public static String renderPageWithSetupsAndTeardowns(
   PageData pageData, boolean isSuite
 ) throws Exception {
   boolean isTestPage = pageData.hasAttribute("Test");
   if (isTestPage) {
     WikiPage testPage = pageData.getWikiPage();
     StringBuffer newPageContent = new StringBuffer();
     includeSetupPages(testPage, newPageContent, isSuite);
     newPageContent.append(pageData.getContent());
     includeTeardownPages(testPage, newPageContent, isSuite);
     pageData.setContent(newPageContent.toString());
   }
     return pageData.getHtml();
 }
 //////
 public static String renderPageWithSetupsAndTeardowns(
   PageData pageData, boolean isSuite) throws Exception {
   if (isTestPage(pageData))
     includeSetupAndTeardownPages(pageData, isSuite);
   return pageData.getHtml();
 }
 //////
 public Money calculatePay(Employee e)
 throws InvalidEmployeeType {
     switch (e.type) {
       case COMMISSIONED:
         return calculateCommissionedPay(e);
       case HOURLY:
         return calculateHourlyPay(e);
       case SALARIED:
         return calculateSalariedPay(e);
       default:
         throw new InvalidEmployeeType(e.type);
   }
 }
 //////
 public abstract class Employee {
    public abstract boolean isPayday();
    public abstract Money calculatePay();
    public abstract void deliverPay(Money pay);
  }
  -----------------
  public interface EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
  }
  -----------------
  public class EmployeeFactoryImpl implements EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
      switch (r.type) {
        case COMMISSIONED:
          return new CommissionedEmployee(r) ;
      case HOURLY:
        return new HourlyEmployee(r);
      case SALARIED:
        return new SalariedEmploye(r);
      default:
        throw new InvalidEmployeeType(r.type);
      }
    }
  }
 
 ////
  public class UserValidator {
    private Cryptographer cryptographer;
  
    public boolean checkPassword(String userName, String password) {
      User user = UserGateway.findByName(userName);
      if (user != User.NULL) {
        String codedPhrase = user.getPhraseEncodedByPassword();
        String phrase = cryptographer.decrypt(codedPhrase, password);
        if ("Has�o prawid�owe".equals(phrase)) {
          Session.initialize();
          return true;
        }
      }
      return false;
    }
  }
 
 ////////
  package fitnesse.html;
 
  import fitnesse.responders.run.SuiteResponder;
  import fitnesse.wiki.*;
  
  public class SetupTeardownIncluder {
    private PageData pageData;
    private boolean isSuite;
    private WikiPage testPage;
    private StringBuffer newPageContent;
    private PageCrawler pageCrawler;
  
    public static String render(PageData pageData) throws Exception {
      return render(pageData, false);
    }
  
    public static String render(PageData pageData, boolean isSuite)
      throws Exception {
      return new SetupTeardownIncluder(pageData).render(isSuite);
    }
  
    private SetupTeardownIncluder(PageData pageData) {
      this.pageData = pageData;
      testPage = pageData.getWikiPage();
      pageCrawler = testPage.getPageCrawler();
      newPageContent = new StringBuffer();
    }
  
    private String render(boolean isSuite) throws Exception {
      this.isSuite = isSuite;
      if (isTestPage())
        includeSetupAndTeardownPages();
      return pageData.getHtml();
    }
  
    private boolean isTestPage() throws Exception {
      return pageData.hasAttribute("Test");
    }
  
    private void includeSetupAndTeardownPages() throws Exception {
      includeSetupPages();
      includePageContent();
      includeTeardownPages();
      updatePageContent();
    }
  
    private void includeSetupPages() throws Exception {
      if (isSuite)
        includeSuiteSetupPage();
      includeSetupPage();
    }
  
    private void includeSuiteSetupPage() throws Exception {
      include(SuiteResponder.SUITE_SETUP_NAME, "-setup");
    }
  
    private void includeSetupPage() throws Exception {
      include("SetUp", "-setup");
    }
  
    private void includePageContent() throws Exception {
      newPageContent.append(pageData.getContent());
    }
  
    private void includeTeardownPages() throws Exception {
      includeTeardownPage();
      if (isSuite)
        includeSuiteTeardownPage();
    }
  
    private void includeTeardownPage() throws Exception {
      include("TearDown", "-teardown");
    }
  
    private void includeSuiteTeardownPage() throws Exception {
      include(SuiteResponder.SUITE_TEARDOWN_NAME, "-teardown");
    }
  
    private void updatePageContent() throws Exception {
      pageData.setContent(newPageContent.toString());
    }
  
    private void include(String pageName, String arg) throws Exception {
      WikiPage inheritedPage = findInheritedPage(pageName);
      if (inheritedPage != null) {
        String pagePathName = getPathNameForPage(inheritedPage);
        buildIncludeDirective(pagePathName, arg);
      }
    }
  
    private WikiPage findInheritedPage(String pageName) throws Exception {
      return PageCrawlerImpl.getInheritedPage(pageName, testPage);
    }
  
    private String getPathNameForPage(WikiPage page) throws Exception {
      WikiPagePath pagePath = pageCrawler.getFullPath(page);
      return PathParser.render(pagePath);
    }
  
    private void buildIncludeDirective(String pagePathName, String arg) {
      newPageContent
        .append("\n!include ")
        .append(arg)
        .append(" .")
        .append(pagePathName)
        .append("\n");
    }
  }
 
 //////
 // Metoda u�ytkowa ko�cz�ca prac� gdy this.closed ma wart�� true. Zg�asza wyj�tek
 // je�eli przekroczony zostanie czas oczekiwania.
 public synchronized void waitForClose(final long timeoutMillis)
   throws Exception
 {
   if(!closed)
   {
     wait(timeoutMillis);
     if(!closed)
       throw new Exception("MockResponseSender could not be closed");
   }
 }
 ////
 public abstract class ContainerBase
   implements Container, Lifecycle, Pipeline,
   MBeanRegistration, Serializable {
 
   /**
    * The processor delay for this component.
    */
   protected int backgroundProcessorDelay = -1;
 
   /**
    * The lifecycle event support for this component.
    */
   protected LifecycleSupport lifecycle =
     new LifecycleSupport(this);
 
   /**
    * The container event listeners for this Container.
    */
   protected ArrayList listeners = new ArrayList();
   
   /**
    * The Loader implementation with which this Container is
    * associated.
    */
   protected Loader loader = null;
 
   /**
    * The Logger implementation with which this Container is
    * associated.
    */
   protected Log logger = null;
 
   /**
    * Associated logger name.
    */
   protected String logName = null;
 
   /**
    * The Manager implementation with which this Container is
    * associated.
    */
   protected Manager manager = null;
 
   /**
    * The cluster with which this Container is associated.
    */
   protected Cluster cluster = null;
 
   /**
    * The human-readable name of this Container.
    */
   protected String name = null;
 
   /**
    * The parent Container to which this Container is a child.
    */
   protected Container parent = null;
 
   /**
    * The parent class loader to be configured when we install a
    * Loader.
    */
   protected ClassLoader parentClassLoader = null;
 
   /**
    * The Pipeline object with which this Container is
    * associated.
    */
   protected Pipeline pipeline = new StandardPipeline(this);
 
   /**
    * The Realm with which this Container is associated.
    */
   protected Realm realm = null;
 
   /**
    * The resources DirContext object with which this Container
    * is associated.
    */
   protected DirContext resources = null;
 
 ////////
 
 /**
  *
  * @param title Tytu� p�yty CD
  * @param author Autor p�yty CD
  * @param tracks Liczba �cie�ek na p�ycie CD
  * @param durationInMinutes Czas odtwarzania CD w minutach
  */
 public void addCD(String title, String author,
                   int tracks, int durationInMinutes) {
   CD cd = new CD();
   cd.title = title;
   cd.author = author;
   cd.tracks = tracks;
   cd.duration = duration;
   cdList.add(cd);
 }
 
 /////////
 private void startSending()
 {
   try
   {
     doSending();
   }
   catch(SocketException e)
   {
     // normalne. kto� zatrzyma� ��danie.
   }
   catch(Exception e)
   {
     try
     {
       response.add(ErrorResponder.makeExceptionString(e));
       response.closeAll();
     }
     catch(Exception e1)
     {
       // Musz� zrobi� przerw�!
     }
   }
 }
 
 ////////
 
 private void startSending()
 {
   try
   {
     doSending();
   }
   catch(SocketException e)
   {
     // normalne. kto� zatrzyma� ��danie.
   }
   catch(Exception e)
   {
     addExceptionAndCloseResponse(e);
   }
 }
 
 private void addExceptionAndCloseResponse(Exception e)
 {
   try
   {
     response.add(ErrorResponder.makeExceptionString(e));
     response.closeAll();
   }
   catch(Exception e1)
   {}
 }
 
 //////////
 public class wc {
    public static void main(String[] args) {
      BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
      String line;
      int lineCount = 0;
      int charCount = 0;
      int wordCount = 0;
      try {
        while ((line = in.readLine()) != null) {
          lineCount++;
          charCount += line.length();
          String words[] = line.split("\\W");
          wordCount += words.length;
        } //while
        System.out.println("wordCount = " + wordCount);
        System.out.println("lineCount = " + lineCount);
        System.out.println("charCount = " + charCount);
      } // try
      catch (IOException e) {
      System.err.println("Error:" + e.getMessage());
      } //catch
    } //main
  }
 
 //////// 
 
 /**
  * Klasa ta generuje liczby pierwsze do okre�lonego przez u�ytkownika
  * maksimum. U�ytym algorytmem jest sito Eratostenesa.
  * <p>
  * Eratostenes z Cyrene, urodzony 276 p.n.e. w Cyrene, Libia --
  * zmar� 194 w Aleksandrii. Pierwszy cz�owiek, kt�ry obliczy�
  * obw�d Ziemi. Znany r�wnie� z prac nad kalendarzem 
  * z latami przest�pnymi i prowadzenia biblioteki w Aleksandrii.
  * <p>
  * Algorytm jest dosy� prosty. Mamy tablic� liczby ca�kowitych
  * zaczynaj�cych si� od 2. Wykre�lamy wszystkie wielokrotno�ci 2. Szukamy
  * nast�pnej niewykre�lonej liczby i wykre�lamy wszystkie jej wielokrotno�ci.
  * Powtarzamy do momentu osi�gni�cia pierwiastka kwadratowego z maksymalnej warto�ci.
  *
  * @author Alphonse
  * @version 13 Feb 2002 atp
 */
 import java.util.*;
 
   public class GeneratePrimes
   {
   /**
   * @param maxValue jest limitem generacji.
   */
 
   public static int[] generatePrimes(int maxValue)
   {
     if (maxValue >= 2) // jedyny prawid�owy przypadek
     {
       // deklaracje
       int s = maxValue + 1; // rozmiar tablicy
       boolean[] f = new boolean[s];
       int i;
       // inicjalizacja tablicy warto�ciami true.
       for (i = 0; i < s; i++)
         f[i] = true;
       // usuwanie znanych liczb nie b�d�cych pierwszymi
       f[0] = f[1] = false;
       // sito
       int j;
       for (i = 2; i < Math.sqrt(s) + 1; i++)
       {
         if (f[i]) // je�eli i nie jest wykre�lone, wykre�lamy jego wielokrotno�ci.
         {
           for (j = 2 * i; j < s; j += i)
             f[j] = false; // wielokrotno�ci nie s� pierwsze
         }
       }
 
       // ile mamy liczb pierwszych?
       int count = 0;
       for (i = 0; i < s; i++)
       {
         if (f[i])
           count++; // licznik trafie�.
       }
 
       int[] primes = new int[count];
 
       // przeniesienie liczb pierwszych do wyniku
       for (i = 0, j = 0; i < s; i++)
       {
         if (f[i]) // je�eli pierwsza
           primes[j++] = i;
       }
       return primes; // zwracamy liczby pierwsze
     }
     else // maxValue < 2
       return new int[0]; // zwracamy pust� tablic� je�eli niew�a�ciwe dane wej�ciowe.
     }
 }
 
 //////////
 
 /**
  * Klasa ta generuje liczby pierwsze do okre�lonego przez u�ytkownika
  * maksimum. U�ytym algorytmem jest sito Eratostenesa.
 * Mamy tablic� lczb ca�kowitych zaczynaj�cych si� od 2:
 * Wyszukujemy pierwsz� nieskre�lon� liczb� i wykre�lamy wszystkie jej 
 * wielokrotno�ci. Powtarzamy a� nie b�dzie wi�cej wielokrotno�ci w tablicy.
 */
 
 public class PrimeGenerator
 {
   private static boolean[] crossedOut;
   private static int[] result;
 
   public static int[] generatePrimes(int maxValue)
   {
     if (maxValue < 2)
       return new int[0];
     else
     {
       uncrossIntegersUpTo(maxValue);
       crossOutMultiples();
       putUncrossedIntegersIntoResult();
       return result;
     }
   }
 
   private static void uncrossIntegersUpTo(int maxValue)
   {
     crossedOut = new boolean[maxValue + 1];
     for (int i = 2; i < crossedOut.length; i++)
       crossedOut[i] = false;
   }
 
   private static void crossOutMultiples()
   {
     int limit = determineIterationLimit();
     for (int i = 2; i <= limit; i++)
       if (notCrossed(i))
         crossOutMultiplesOf(i);
   }
 
   private static int determineIterationLimit()
   {
     // Ka�ada wielokrotno�� w tablicy ma podzielnik b�d�cy liczb� pierwsz�
     // mniejsz� lub r�wn� pierwiastkowi kwadratowemu wielko�ci tablicy,
     // wi�c nie musimy wykre�la� wielokrotno�ci wi�kszych od tego pierwiastka.
     double iterationLimit = Math.sqrt(crossedOut.length);
     return (int) iterationLimit;
   }
 
   private static void crossOutMultiplesOf(int i)
   {
     for (int multiple = 2*i;
          multiple < crossedOut.length;
          multiple += i)
       crossedOut[multiple] = true;
   }
 
   private static boolean notCrossed(int i)
   {
     return crossedOut[i] == false;
   }
 
   private static void putUncrossedIntegersIntoResult()
   {
     result = new int[numberOfUncrossedIntegers()];
     for (int j = 0, i = 2; i < crossedOut.length; i++)
       if (notCrossed(i))
         result[j++] = i;
   }
 
   private static int numberOfUncrossedIntegers()
   {
     int count = 0;
     for (int i = 2; i < crossedOut.length; i++)
       if (notCrossed(i))
         count++;
 
     return count;
   }
 }
 
 ///////////
 
 package fitnesse.wikitext.widgets;
 
 import java.util.regex.*;
 
 public class BoldWidget extends ParentWidget {
   public static final String REGEXP = "'''.+?'''";
   private static final Pattern pattern = Pattern.compile("'''(.+?)'''",
     Pattern.MULTILINE + Pattern.DOTALL
   );
 
   public BoldWidget(ParentWidget parent, String text) throws Exception {
     super(parent);
     Matcher match = pattern.matcher(text);
     match.find();
     addChildWidgets(match.group(1));
   }
 
   public String render() throws Exception {
     StringBuffer html = new StringBuffer("<b>");
     html.append(childHtml()).append("</b>");
     return html.toString();
   }
 }
 
 ////////
 
 package fitnesse.wikitext.widgets;
 import java.util.regex.*;
 public class BoldWidget extends ParentWidget {
   public static final String REGEXP = "'''.+?'''";
   private static final Pattern pattern = Pattern.compile("'''(.+?)'''",
     Pattern.MULTILINE + Pattern.DOTALL);
   public BoldWidget(ParentWidget parent, String text) throws Exception {
     super(parent);
     Matcher match = pattern.matcher(text);
     match.find();
     addChildWidgets(match.group(1));}
   public String render() throws Exception {
     StringBuffer html = new StringBuffer("<b>");
     html.append(childHtml()).append("</b>");
     return html.toString();
   }
 }
 
 //////////
 
 public class ReporterConfig {
 
    /**
     * Nazwa klasy nas�uchu raportu
     */
  private String m_className;
  
    /**
     * W�a�ciwo�ci nas�uchu raportu
     */
  private List<Property> m_properties = new ArrayList<Property>();
  
  public void addProperty(Property property) {
    m_properties.add(property);
  }
 
 ////////////
 
 public class ReporterConfig {
    private String m_className;
    private List<Property> m_properties = new ArrayList<Property>();
  
    public void addProperty(Property property) {
      m_properties.add(property);
  }
 
 /////////////
 
 public class WikiPageResponder implements SecureResponder {
    protected WikiPage page;
    protected PageData pageData;
    protected String pageTitle;
    protected Request request;
    protected PageCrawler crawler;
    
    public Response makeResponse(FitNesseContext context, Request request)
      throws Exception {
      String pageName = getPageNameOrDefault(request, "FrontPage");
      loadPage(pageName, context);
      if (page == null)
        return notFoundResponse(context, request);
      else
        return makePageResponse(context);
    }
  
    private String getPageNameOrDefault(Request request, String defaultPageName)
    {
      String pageName = request.getResource();
      if (StringUtil.isBlank(pageName))
        pageName = defaultPageName;
  
      return pageName;
    }
  
    protected void loadPage(String resource, FitNesseContext context)
      throws Exception {
      WikiPagePath path = PathParser.parse(resource);
      crawler = context.root.getPageCrawler();
      crawler.setDeadEndStrategy(new VirtualEnabledPageCrawler());
      page = crawler.getPage(context.root, path);
      if (page != null)
        pageData = page.getData();
    }
  
    private Response notFoundResponse(FitNesseContext context, Request request)
      throws Exception {
      return new NotFoundResponder().makeResponse(context, request);
    }
  
    private SimpleResponse makePageResponse(FitNesseContext context)
      throws Exception {
      pageTitle = PathParser.render(crawler.getFullPath(page));
      String html = makeHtml(context);
  
      SimpleResponse response = new SimpleResponse();
      response.setMaxAge(0);
      response.setContent(html);
      return response;
    }
    ...
 
 //////////
 
 public class CodeAnalyzer implements JavaFileAnalysis {
    private int lineCount;
    private int maxLineWidth;
    private int widestLineNumber;
    private LineWidthHistogram lineWidthHistogram;
    private int totalChars;
  
    public CodeAnalyzer() {
      lineWidthHistogram = new LineWidthHistogram();
    }
  
    public static List<File> findJavaFiles(File parentDirectory) {
      List<File> files = new ArrayList<File>();
      findJavaFiles(parentDirectory, files);
      return files;
    }
  
    private static void findJavaFiles(File parentDirectory, List<File> files) {
      for (File file : parentDirectory.listFiles()) {
        if (file.getName().endsWith(".java"))
          files.add(file);
        else if (file.isDirectory())
          findJavaFiles(file, files);
      }
    }
  
    public void analyzeFile(File javaFile) throws Exception {
      BufferedReader br = new BufferedReader(new FileReader(javaFile));
      String line;
      while ((line = br.readLine()) != null)
        measureLine(line);
    }
  
    private void measureLine(String line) {
      lineCount++;
      int lineSize = line.length();
      totalChars += lineSize;
      lineWidthHistogram.addLine(lineSize, lineCount);
      recordWidestLine(lineSize);
    }
  
    private void recordWidestLine(int lineSize) {
      if (lineSize > maxLineWidth) {
        maxLineWidth = lineSize;
        widestLineNumber = lineCount;
      }
    }
  
    public int getLineCount() {
      return lineCount;
    }
  
    public int getMaxLineWidth() {
      return maxLineWidth;
    }
  
    public int getWidestLineNumber() {
      return widestLineNumber;
    }
  
    public LineWidthHistogram getLineWidthHistogram() {
      return lineWidthHistogram;
    }
  
    public double getMeanLineWidth() {
      return (double)totalChars/lineCount;
    }
  
    public int getMedianLineWidth() {
      Integer[] sortedWidths = getSortedWidths();
      int cumulativeLineCount = 0;
      for (int width : sortedWidths) {
        cumulativeLineCount += lineCountForWidth(width);
        if (cumulativeLineCount > lineCount/2)
          return width;
      }
      throw new Error("Nie mo�na tu wej��");
    }
  
    private int lineCountForWidth(int width) {
      return lineWidthHistogram.getLinesforWidth(width).size();
    }
  
    private Integer[] getSortedWidths() {
      Set<Integer> widths = lineWidthHistogram.getWidths();
      Integer[] sortedWidths = (widths.toArray(new Integer[0]));
      Arrays.sort(sortedWidths);
      return sortedWidths;
    }
  }
 
 //////////
 
 public class Point {
    public double x;
    public double y;
  }
 
 ///////////
 
 public interface Point {
    double getX();
    double getY();
    void setCartesian(double x, double y);
    double getR();
    double getTheta();
    void setPolar(double r, double theta);
  }
 
 /////////
 
 public interface Vehicle {
    double getFuelTankCapacityInGallons();
    double getGallonsOfGasoline();
  }
 
 //////////
 
 public interface Vehicle {
    double getPercentFuelRemaining();
  }
 
 ///////////
 
 public class Square {
    public Point topLeft;
    public double side;
    }
  
  public class Rectangle {
    public Point topLeft;
    public double height;
    public double width;
  }
  
  public class Circle {
    public Point center;
    public double radius;
  }
  
  public class Geometry {
    public final double PI = 3.141592653589793;
  
    public double area(Object shape) throws NoSuchShapeException
    {
      if (shape instanceof Square) {
        Square s = (Square)shape;
        return s.side * s.side;
      }
      else if (shape instanceof Rectangle) {
        Rectangle r = (Rectangle)shape;
        return r.height * r.width;
      }
      else if (shape instanceof Circle) {
        Circle c = (Circle)shape;
        return PI * c.radius * c.radius;
      }
      throw new NoSuchShapeException();
    }
  }
 
 /////////
 
 public class Square implements Shape {
    private Point topLeft;
      private double side;
  
      public double area() {
        return side*side;
      }
  }
  
  public class Rectangle implements Shape {
    private Point topLeft;
    private double height;
    private double width;
  
    public double area() {
      return height * width;
    }
  }
  
    public class Circle implements Shape {
    private Point center;
    private double radius;
    public final double PI = 3.141592653589793;
  
    public double area() {
      return PI * radius * radius;
    }
  }
 
 /////////
 
 public class Address {
    private String street;
    private String streetExtra;
    private String city;
    private String state;
    private String zip;
  
    public Address(String street, String streetExtra,
      String city, String state, String zip) {
      this.street = street;
      this.streetExtra = streetExtra;
      this.city = city;
      this.state = state;
      this.zip = zip;
    }
  
    public String getStreet() {
      return street;
    }
  
    public String getStreetExtra() {
      return streetExtra;
    }
  
    public String getCity() {
      return city;
    }
  
    public String getState() {
      return state;
    }
  
    public String getZip() {
      return zip;
    }
  }
 
 ///////////////
 
 public class DeviceController {
    ...
    public void sendShutDown() {
      DeviceHandle handle = getHandle(DEV1);
      // Sprawdzenie stanu urz�dzenia
      if (handle != DeviceHandle.INVALID) {
        // Zapisanie stanu urz�dzenia w polu rekordu
        retrieveDeviceRecord(handle);
        // Je�eli nie wstrzymane, wy��czenie
        if (record.getStatus() != DEVICE_SUSPENDED) {
          pauseDevice(handle);
          clearDeviceWorkQueue(handle);
          closeDevice(handle);
        } else {
          logger.log("Urz�dzenie wstrzymane. Nie mo�na wy��czy�");
        }
      } else {
        logger.log("Niew�a�ciwy uchwyt dla: " + DEV1.toString());
      }
    }
    ...
  }
 
 ///////////////////
 
 public class DeviceController {
    ...
    public void sendShutDown() {
      try {
        tryToShutDown();
      } catch (DeviceShutDownError e) {
        logger.log(e);
      }
    }
  
    private void tryToShutDown() throws DeviceShutDownError {
      DeviceHandle handle = getHandle(DEV1);
      DeviceRecord record = retrieveDeviceRecord(handle);
    
      pauseDevice(handle);
      clearDeviceWorkQueue(handle);
      closeDevice(handle);
    }
  
    private DeviceHandle getHandle(DeviceID id) {
      ...
      throw new DeviceShutDownError("Niew�a�ciwy uchwyt dla: " + id.toString());
      ...
    }
    ...
  }
 
 ////////////////
 
 public class LogTest {
    private Logger logger;
 
    @Before
    public void initialize() {
        logger = Logger.getLogger("logger");
        logger.removeAllAppenders();
        Logger.getRootLogger().removeAllAppenders();
    }
    @Test
    public void basicLogger() {
        BasicConfigurator.configure();
        logger.info("basicLogger");
    }
 
    @Test
    public void addAppenderWithStream() {
      logger.addAppender(new ConsoleAppender(
        new PatternLayout("%p %t %m%n"),
        ConsoleAppender.SYSTEM_OUT));
      logger.info("addAppenderWithStream");
    }
    @Test
    public void addAppenderWithoutStream() {
      logger.addAppender(new ConsoleAppender(
        new PatternLayout("%p %t %m%n")));
      logger.info("addAppenderWithoutStream");
    }
 }
 
 //////////////////
 
 public void testGetPageHieratchyAsXml() throws Exception
 {
   crawler.addPage(root, PathParser.parse("PageOne"));
   crawler.addPage(root, PathParser.parse("PageOne.ChildOne"));
   crawler.addPage(root, PathParser.parse("PageTwo"));
 
   request.setResource("root");
   request.addInput("type", "pages");
   Responder responder = new SerializedPageResponder();
   SimpleResponse response =
     (SimpleResponse) responder.makeResponse(
       new FitNesseContext(root), request);
   String xml = response.getContent();
 
   assertEquals("text/xml", response.getContentType());
   assertSubString("<name>PageOne</name>", xml);
   assertSubString("<name>PageTwo</name>", xml);
   assertSubString("<name>ChildOne</name>", xml);
 }
 
 public void testGetPageHieratchyAsXmlDoesntContainSymbolicLinks()
 throws Exception
 {
   WikiPage pageOne = crawler.addPage(root, PathParser.parse("PageOne"));
   crawler.addPage(root, PathParser.parse("PageOne.ChildOne"));
   crawler.addPage(root, PathParser.parse("PageTwo"));
 
   PageData data = pageOne.getData();
   WikiPageProperties properties = data.getProperties();
   WikiPageProperty symLinks = properties.set(SymbolicPage.PROPERTY_NAME);
   symLinks.set("SymPage", "PageTwo");
   pageOne.commit(data);
 
   request.setResource("root");
   request.addInput("type", "pages");
   Responder responder = new SerializedPageResponder();
   SimpleResponse response =
     (SimpleResponse) responder.makeResponse(
       new FitNesseContext(root), request);
   String xml = response.getContent();
 
   assertEquals("text/xml", response.getContentType());
   assertSubString("<name>PageOne</name>", xml);
   assertSubString("<name>PageTwo</name>", xml);
   assertSubString("<name>ChildOne</name>", xml);
   assertNotSubString("SymPage", xml);
 }
 
 public void testGetDataAsHtml() throws Exception
 {
   crawler.addPage(root, PathParser.parse("TestPageOne"), "test page");
 
   request.setResource("TestPageOne");
   request.addInput("type", "data");
   Responder responder = new SerializedPageResponder();
   SimpleResponse response =
     (SimpleResponse) responder.makeResponse(
       new FitNesseContext(root), request);
   String xml = response.getContent();
 
   assertEquals("text/xml", response.getContentType());
   assertSubString("test page", xml);
   assertSubString("<Test", xml);
 }
 
 ///////////
 
 public void testGetPageHierarchyAsXml() throws Exception {
    makePages("PageOne", "PageOne.ChildOne", "PageTwo");
  
    submitRequest("root", "type:pages");
  
    assertResponseIsXML();
    assertResponseContains(
      "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
    );
  }
  
  public void testSymbolicLinksAreNotInXmlPageHierarchy() throws Exception {
    WikiPage page = makePage("PageOne");
    makePages("PageOne.ChildOne", "PageTwo");
  
    addLinkTo(page, "PageTwo", "SymPage");
  
    submitRequest("root", "type:pages");
  
    assertResponseIsXML();
    assertResponseContains(
      "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
    );
    assertResponseDoesNotContain("SymPage");
  }
  
  public void testGetDataAsXml() throws Exception {
    makePageWithContent("TestPageOne", "test page");
  
    submitRequest("TestPageOne", "type:data");
  
    assertResponseIsXML();
    assertResponseContains("test page", "<Test");
  }
 
 ///////////
 
 @Test
   public void turnOnLoTempAlarmAtThreashold() throws Exception {
     hw.setTemp(WAY_TOO_COLD);
     controller.tic();
     assertTrue(hw.heaterState());
     assertTrue(hw.blowerState());
     assertFalse(hw.coolerState());
     assertFalse(hw.hiTempAlarm());
     assertTrue(hw.loTempAlarm());
   }
 
 //////////
 
 @Test
   public void turnOnLoTempAlarmAtThreshold() throws Exception {
     wayTooCold();
     assertEquals("HBchL", hw.getState());
   }
 
 ///////////
 
 @Test
   public void turnOnCoolerAndBlowerIfTooHot() throws Exception {
     tooHot();
     assertEquals("hBChl", hw.getState());
   }
 
   @Test
   public void turnOnHeaterAndBlowerIfTooCold() throws Exception {
     tooCold();
     assertEquals("HBchl", hw.getState());
   }
 
   @Test
   public void turnOnHiTempAlarmAtThreshold() throws Exception {
     wayTooHot();
     assertEquals("hBCHl", hw.getState());
   }
 
   @Test
   public void turnOnLoTempAlarmAtThreshold() throws Exception {
     wayTooCold();
     assertEquals("HBchL", hw.getState());
   }
 
 ///////////
 
 public String getState() {
    String state = "";
    state += heater ? "H" : "h";
    state += blower ? "B" : "b";
    state += cooler ? "C" : "c";
    state += hiTempAlarm ? "H" : "h";
    state += loTempAlarm ? "L" : "l";
    return state;
 }
 
 ////////////
 
 public void testGetPageHierarchyAsXml() throws Exception {
    givenPages("PageOne", "PageOne.ChildOne", "PageTwo");
 
    whenRequestIsIssued("root", "type:pages");
 
    thenResponseShouldBeXML();
  }
 
  public void testGetPageHierarchyHasRightTags() throws Exception {
    givenPages("PageOne", "PageOne.ChildOne", "PageTwo");
 
    whenRequestIsIssued("root", "type:pages");
 
    thenResponseShouldContain(
      "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
    );
  }
 
 ///////////////
 
 /**
  * R�ne testy metody addMonths().
  */
 public void testAddMonths() {
    SerialDate d1 = SerialDate.createInstance(31, 5, 2004);
  
    SerialDate d2 = SerialDate.addMonths(1, d1);
    assertEquals(30, d2.getDayOfMonth());
    assertEquals(6, d2.getMonth());
    assertEquals(2004, d2.getYYYY());
  
    SerialDate d3 = SerialDate.addMonths(2, d1);
    assertEquals(31, d3.getDayOfMonth());
    assertEquals(7, d3.getMonth());
    assertEquals(2004, d3.getYYYY());
  
    SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1));
    assertEquals(30, d4.getDayOfMonth());
    assertEquals(7, d4.getMonth());
    assertEquals(2004, d4.getYYYY());
  }
 
 /////////////////
 
 public class SuperDashboard extends JFrame implements MetaDataUser
   public String getCustomizerLanguagePath()
   public void setSystemConfigPath(String systemConfigPath)
   public String getSystemConfigDocument()
   public void setSystemConfigDocument(String systemConfigDocument)
   public boolean getGuruState()
   public boolean getNoviceState()
   public boolean getOpenSourceState()
   public void showObject(MetaObject object)
   public void showProgress(String s)
   public boolean isMetadataDirty()
   public void setIsMetadataDirty(boolean isMetadataDirty)
   public Component getLastFocusedComponent()
   public void setLastFocused(Component lastFocused)
   public void setMouseSelectState(boolean isMouseSelected)
   public boolean isMouseSelected()
   public LanguageManager getLanguageManager()
   public Project getProject()
   public Project getFirstProject()
   public Project getLastProject()
   public String getNewProjectName()
   public void setComponentSizes(Dimension dim)
   public String getCurrentDir()
   public void setCurrentDir(String newDir)
   public void updateStatus(int dotPos, int markPos)
   public Class[] getDataBaseClasses()
   public MetadataFeeder getMetadataFeeder()
   public void addProject(Project project)
   public boolean setCurrentProject(Project project)
   public boolean removeProject(Project project)
   public MetaProjectHeader getProgramMetadata()
   public void resetDashboard()
   public Project loadProject(String fileName, String projectName)
   public void setCanSaveMetadata(boolean canSave)
   public MetaObject getSelectedObject()
   public void deselectObjects()
   public void setProject(Project project)
   public void editorAction(String actionName, ActionEvent event)
   public void setMode(int mode)
   public FileManager getFileManager()
   public void setFileManager(FileManager fileManager)
   public ConfigManager getConfigManager()
   public void setConfigManager(ConfigManager configManager)
   public ClassLoader getClassLoader()
   public void setClassLoader(ClassLoader classLoader)
   public Properties getProps()
   public String getUserHome()
   public String getBaseDir()
   public int getMajorVersionNumber()
   public int getMinorVersionNumber()
   public int getBuildNumber()
   public MetaObject pasting(
     MetaObject target, MetaObject pasted, MetaProject project)
   public void processMenuItems(MetaObject metaObject)
   public void processMenuSeparators(MetaObject metaObject)
   public void processTabPages(MetaObject metaObject)
   public void processPlacement(MetaObject object)
   public void processCreateLayout(MetaObject object)
   public void updateDisplayLayer(MetaObject object, int layerIndex)
   public void propertyEditedRepaint(MetaObject object)
   public void processDeleteObject(MetaObject object)
   public boolean getAttachedToDesigner()
   public void processProjectChangedState(boolean hasProjectChanged)
   public void processObjectNameChanged(MetaObject object)
   public void runProject()
   public void setA�owDragging(boolean allowDragging)
   public boolean allowDragging()
   public boolean isCustomizing()
   public void setTitle(String title)
   public IdeMenuBar getIdeMenuBar()
   public void showHelper(MetaObject metaObject, String propertyName)
   // ... Wiele kolejnych niepublicznych metod ...
 }
 
 ///////////////
 
 public class SuperDashboard extends JFrame implements MetaDataUser
   public Component getLastFocusedComponent()
   public void setLastFocused(Component lastFocused)
   public int getMajorVersionNumber()
   public int getMinorVersionNumber()
   public int getBuildNumber()
 }
 
 ///////////////
 
 public class Version {
    public int getMajorVersionNumber()
    public int getMinorVersionNumber()
    public int getBuildNumber()
  }
 
 ///////////////////
 
 public class Stack {
    private int topOfStack = 0;
    List<Integer> elements = new LinkedList<Integer>();
  
    public int size() {
      return topOfStack;
    }
  
    public void push(int element) {
      topOfStack++;
      elements.add(element);
    }
  
    public int pop() throws PoppedWhenEmpty {
      if (topOfStack == 0)
        throw new PoppedWhenEmpty();
      int element = elements.get(--topOfStack);
      elements.remove(topOfStack);
      return element;
    }
  }
 //////////////
 
 package literatePrimes;
 
 public class PrintPrimes {
   public static void main(String[] args) {
     final int M = 1000;
     final int RR = 50;
     final int CC = 4;
     final int WW = 10;
     final int ORDMAX = 30;
     int P[] = new int[M + 1];
     int PAGENUMBER;
     int PAGEOFFSET;
     int ROWOFFSET;
     int C;
     int J;
     int K;
     boolean JPRIME;
     int ORD;
     int SQUARE;
     int N;
     int MULT[] = new int[ORDMAX + 1];
 
     J = 1;
     K = 1;
     P[1] = 2;
     ORD = 2;
     SQUARE = 9;
 
     while (K < M) {
       do {
         J = J + 2;
         if (J == SQUARE) {
           ORD = ORD + 1;
           SQUARE = P[ORD] * P[ORD];
           MULT[ORD - 1] = J;
         }
         N = 2;
         JPRIME = true;
         while (N < ORD && JPRIME) {
           while (MULT[N] < J)
             MULT[N] = MULT[N] + P[N] + P[N];
           if (MULT[N] == J)
             JPRIME = false;
           N = N + 1;
         }
       } while (!JPRIME);
       K = K + 1;
       P[K] = J;
     }
     {
       PAGENUMBER = 1;
       PAGEOFFSET = 1;
       while (PAGEOFFSET <= M) {
         System.out.println("Pierwsze " + M +
                            " liczb pierwszych --- strona " + PAGENUMBER);
         System.out.println("");
         for (ROWOFFSET = PAGEOFFSET; ROWOFFSET < PAGEOFFSET + RR; ROWOFFSET++){
           for (C = 0; C < CC;C++)
             if (ROWOFFSET + C * RR <= M)
               System.out.format("%10d", P[ROWOFFSET + C * RR]);
           System.out.println("");
         }
         System.out.println("\f");
         PAGENUMBER = PAGENUMBER + 1;
         PAGEOFFSET = PAGEOFFSET + RR * CC;
       }
     }
   }
 }
 
 /////////////////
 
 package literatePrimes;
 
 public class PrimePrinter {
   public static void main(String[] args) {
     final int NUMBER_OF_PRIMES = 1000;
     int[] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES);
 
     final int ROWS_PER_PAGE = 50;
     final int COLUMNS_PER_PAGE = 4;
     RowColumnPagePrinter tablePrinter =
       new RowColumnPagePrinter(ROWS_PER_PAGE,
                                COLUMNS_PER_PAGE,
                                "Pierwsze " + NUMBER_OF_PRIMES +
                                " liczb pierwszych");
     tablePrinter.print(primes);
   }
 }
 
 ///////////////////
 
 package literatePrimes;
 
 import java.io.PrintStream;
 
 public class RowColumnPagePrinter {
   private int rowsPerPage;
   private int columnsPerPage;
   private int numbersPerPage;
   private String pageHeader;
   private PrintStream printStream;
 
   public RowColumnPagePrinter(int rowsPerPage,
                               int columnsPerPage,
                               String pageHeader) {
     this.rowsPerPage = rowsPerPage;
     this.columnsPerPage = columnsPerPage;
     this.pageHeader = pageHeader;
     numbersPerPage = rowsPerPage * columnsPerPage;
     printStream = System.out;
   }
 
   public void print(int data[]) {
     int pageNumber = 1;
     for (int firstIndexOnPage = 0;
          firstIndexOnPage < data.length;
          firstIndexOnPage += numbersPerPage) {
       int lastIndexOnPage =
         Math.min(firstIndexOnPage + numbersPerPage - 1,
                  data.length - 1);
       printPageHeader(pageHeader, pageNumber);
       printPage(firstIndexOnPage, lastIndexOnPage, data);
       printStream.println("\f");
       pageNumber++;
     }
   }
 
   private void printPage(int firstIndexOnPage,
                          int lastIndexOnPage,
                          int[] data) {
     int firstIndexOfLastRowOnPage =
       firstIndexOnPage + rowsPerPage - 1;
     for (int firstIndexInRow = firstIndexOnPage;
          firstIndexInRow <= firstIndexOfLastRowOnPage;
          firstIndexInRow++) {
       printRow(firstIndexInRow, lastIndexOnPage, data);
       printStream.println("");
     }
   }
 
   private void printRow(int firstIndexInRow,
                         int lastIndexOnPage,
                         int[] data) {
     for (int column = 0; column < columnsPerPage; column++) {
       int index = firstIndexInRow + column * rowsPerPage;
       if (index <= lastIndexOnPage)
         printStream.format("%10d", data[index]);
     }
   }
 
   private void printPageHeader(String pageHeader,
                                int pageNumber) {
     printStream.println(pageHeader + " --- Strona " + pageNumber);
     printStream.println("");
   }
 
   public void setOutput(PrintStream printStream) {
     this.printStream = printStream;
   }
 }
 
 ///////////////////////////
 
 package literatePrimes;
 
 import java.util.ArrayList;
 
 public class PrimeGenerator {
   private static int[] primes;
   private static ArrayList<Integer> multiplesOfPrimeFactors;
 
   protected static int[] generate(int n) {
     primes = new int[n];
     multiplesOfPrimeFactors = new ArrayList<Integer>();
     set2AsFirstPrime();
     checkOddNumbersForSubsequentPrimes();
     return primes;
   }
 
   private static void set2AsFirstPrime() {
     primes[0] = 2;
     multiplesOfPrimeFactors.add(2);
   }
 
   private static void checkOddNumbersForSubsequentPrimes() {
     int primeIndex = 1;
     for (int candidate = 3;
          primeIndex < primes.length;
          candidate += 2) {
       if (isPrime(candidate))
         primes[primeIndex++] = candidate;
     }
   }
 
   private static boolean isPrime(int candidate) {
     if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) {
       multiplesOfPrimeFactors.add(candidate);
       return false;
     }
     return isNotMultipleOfAnyPreviousPrimeFactor(candidate);
   }
 
   private static boolean
   isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) {
     int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()];
     int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor;
     return candidate == leastRelevantMultiple;
   }
 
   private static boolean
   isNotMultipleOfAnyPreviousPrimeFactor(int candidate) {
     for (int n = 1; n < multiplesOfPrimeFactors.size(); n++) {
       if (isMultipleOfNthPrimeFactor(candidate, n))
         return false;
     }
     return true;
   }
 
   private static boolean
   isMultipleOfNthPrimeFactor(int candidate, int n) {
     return
       candidate == smallestOddNthMultipleNotLessThanCandidate(candidate, n);
   }
 
   private static int
   smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) {
     int multiple = multiplesOfPrimeFactors.get(n);
     while (multiple < candidate)
       multiple += 2 * primes[n];
     multiplesOfPrimeFactors.set(n, multiple);
     return multiple;
   }
 }
 
 ////////////////////
 
 public class Sql {
    public Sql(String table, Column[] columns)
    public String create()
    public String insert(Object[] fields)
    public String selectAll()
    public String findByKey(String keyColumn, String keyValue)
    public String select(Column column, String pattern)
    public String select(Criteria criteria)
    public String preparedInsert()
    private String columnList(Column[] columns)
    private String valuesList(Object[] fields, final Column[] columns)
    private String selectWithCriteria(String criteria)
    private String placeholderList(Column[] columns)
  }
 
 /////////////////////
 
 abstract public class Sql {
    public Sql(String table, Column[] columns)
    abstract public String generate();
  }
  
  public class CreateSql extends Sql {
    public CreateSql(String table, Column[] columns)
    @Override public String generate()
  }
  
  public class SelectSql extends Sql {
    public SelectSql(String table, Column[] columns)
    @Override public String generate()
  }
  
  public class InsertSql extends Sql {
    public InsertSql(String table, Column[] columns, Object[] fields)
    @Override public String generate()
    private String valuesList(Object[] fields, final Column[] columns)
  }
  
  public class SelectWithCriteriaSql extends Sql {
    public SelectWithCriteriaSql(
    String table, Column[] columns, Criteria criteria)
    @Override public String generate()
  }
  
  public class SelectWithMatchSql extends Sql {
    public SelectWithMatchSql(
    String table, Column[] columns, Column column, String pattern)
    @Override public String generate()
  }
  
  public class FindByKeySql extends Sql
    public FindByKeySql(
    String table, Column[] columns, String keyColumn, String keyValue)
    @Override public String generate()
  }
  
  public class PreparedInsertSql extends Sql {
    public PreparedInsertSql(String table, Column[] columns)
    @Override public String generate() {
    private String placeholderList(Column[] columns)
  }
  
  public class Where {
    public Where(String criteria)
    public String generate()
  }
  
  public class ColumnList {
    public ColumnList(Column[] columns)
    public String generate()
  }
 
 ///////////////////////////////
 
 package com.example.banking;
 import java.util.Collections;
 import javax.ejb.*;
 
 public interface BankLocal extends java.ejb.EJBLocalObject {
   String getStreetAddr1() throws EJBException;
   String getStreetAddr2() throws EJBException;
   String getCity() throws EJBException;
   String getState() throws EJBException;
   String getZipCode() throws EJBException;
   void setStreetAddr1(String street1) throws EJBException;
   void setStreetAddr2(String street2) throws EJBException;
   void setCity(String city) throws EJBException;
   void setState(String state) throws EJBException;
   void setZipCode(String zip) throws EJBException;
   Collection getAccounts() throws EJBException;
   void setAccounts(Collection accounts) throws EJBException;
   void addAccount(AccountDTO accountDTO) throws EJBException;
 }
 
 //////////////////////////
 
 package com.example.banking;
 import java.util.Collections;
 import javax.ejb.*;
 
 public abstract class Bank implements javax.ejb.EntityBean {
   // Logika biznesowa...
   public abstract String getStreetAddr1();
   public abstract String getStreetAddr2();
   public abstract String getCity();
   public abstract String getState();
   public abstract String getZipCode();
   public abstract void setStreetAddr1(String street1);
   public abstract void setStreetAddr2(String street2);
   public abstract void setCity(String city);
   public abstract void setState(String state);
   public abstract void setZipCode(String zip);
   public abstract Collection getAccounts();
   public abstract void setAccounts(Collection accounts);
   public void addAccount(AccountDTO accountDTO) {
     InitialContext context = new InitialContext();
     AccountHomeLocal accountHome = context.lookup("AccountHomeLocal");
     AccountLocal account = accountHome.create(accountDTO);
     Collection accounts = getAccounts();
     accounts.add(account);
   }
   // Logiga kontenera EJB
   public abstract void setId(Integer id);
   public abstract Integer getId();
   public Integer ejbCreate(Integer id) { ... }
   public void ejbPostCreate(Integer id) { ... }
   // Pozosta�a cz�� musi by� zaimplementowana, ale z regu�y metody s� puste:
   public void setEntityContext(EntityContext ctx) {}
   public void unsetEntityContext() {}
   public void ejbActivate() {}
   public void ejbPassivate() {}
   public void ejbLoad() {}
   public void ejbStore() {}
   public void ejbRemove() {}
 }
 
 //////////////////////////////
 
 // Bank.java (pomini�te nazwy pakiet�w...)
 import java.utils.*;
 
 // Abstrakcja banku.
 public interface Bank {
   Collection<Account> getAccounts();
   void setAccounts(Collection<Account> accounts);
 }
 
 // BankImpl.java
 import java.utils.*;
 
 // Obiekt "Plain Old Java Object" (POJO) implementuj�cy abstrakcj�.
 public class BankImpl implements Bank {
   private List<Account> accounts;
 
   public Collection<Account> getAccounts() {
     return accounts;
   }
   public void setAccounts(Collection<Account> accounts) {
     this.accounts = new ArrayList<Account>();
     for (Account account: accounts) {
       this.accounts.add(account);
     }
   }
 }
 
 // BankProxyHandler.java
 import java.lang.reflect.*;
 import java.util.*;
 // "InvocationHandler" wymagany przez API po�rednika.
 public class BankProxyHandler implements InvocationHandler {
   private Bank bank;
   
   public BankHandler (Bank bank) {
     this.bank = bank;
   }
 
   // Metoda zdefiniowana w InvocationHandler
   public Object invoke(Object proxy, Method method, Object[] args)
       throws Throwable {
     String methodName = method.getName();
     if (methodName.equals("getAccounts")) {
       bank.setAccounts(getAccountsFromDatabase());
       return bank.getAccounts();
     } else if (methodName.equals("setAccounts")) {
       bank.setAccounts((Collection<Account>) args[0]);
       setAccountsToDatabase(bank.getAccounts());
       return null;
     } else {
       ...
     }
   }
 
   // Tutaj sporo szczeg��w:
   protected Collection<Account> getAccountsFromDatabase() { ... }
   protected void setAccountsToDatabase(Collection<Account> accounts) { ... }
 }
 
 // W innym miejscu...
 
 Bank bank = (Bank) Proxy.newProxyInstance(
   Bank.class.getClassLoader(),
   new Class[] { Bank.class },
   new BankProxyHandler(new BankImpl()));
 
 ///////////////////////
 
 package com.example.banking.model;
 import javax.persistence.*;
 import java.util.ArrayList;
 import java.util.Collection;
 
 @Entity
 @Table(name = "BANKS")
 public class Bank implements java.io.Serializable {
   @Id @GeneratedValue(strategy=GenerationType.AUTO)
   private int id;
 
   @Embeddable // Obiekt "wbudowany" w wiersz bazy danych dla obiektu Bank
   public class Address {
     protected String streetAddr1;
     protected String streetAddr2;
     protected String city;
     protected String state;
     protected String zipCode;
   }
 
   @Embedded
   private Address address;
 
   @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER,
              mappedBy="bank")
   private Collection<Account> accounts = new ArrayList<Account>();
 
   public int getId() {
     return id;
   }
 
   public void setId(int id) {
     this.id = id;
   }
 
   public void addAccount(Account account) {
     account.setBank(this);
     accounts.add(account);
   }
 
   public Collection<Account> getAccounts() {
     return accounts;
   }
 
   public void setAccounts(Collection<Account> accounts) {
     this.accounts = accounts;
   }
 }
 
 ////////////////////
 
 public static void main(String[] args) {
    try {
      Args arg = new Args("l,p#,d*", args);
      boolean logging = arg.getBoolean('l');
      int port = arg.getInt('p');
      String directory = arg.getString('d');
      executeApplication(logging, port, directory);
    } catch (ArgsException e) {
      System.out.printf("B��d argument�w: %s\n", e.errorMessage());
    }
  }
 
 ////////////////////
 
 package com.objectmentor.utilities.args;
 
 import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;
 import java.util.*;
 
 public class Args {
   private Map<Character, ArgumentMarshaler> marshalers;
   private Set<Character> argsFound;
   private ListIterator<String> currentArgument;
 
   public Args(String schema, String[] args) throws ArgsException {
     marshalers = new HashMap<Character, ArgumentMarshaler>();
     argsFound = new HashSet<Character>();
 
     parseSchema(schema);
     parseArgumentStrings(Arrays.asList(args));
   }
 
   private void parseSchema(String schema) throws ArgsException {
     for (String element : schema.split(","))
       if (element.length() > 0)
         parseSchemaElement(element.trim());
   }
 
   private void parseSchemaElement(String element) throws ArgsException {
     char elementId = element.charAt(0);
     String elementTail = element.substring(1);
     validateSchemaElementId(elementId);
     if (elementTail.length() == 0)
       marshalers.put(elementId, new BooleanArgumentMarshaler());
     else if (elementTail.equals("*"))
       marshalers.put(elementId, new StringArgumentMarshaler());
     else if (elementTail.equals("#"))
       marshalers.put(elementId, new IntegerArgumentMarshaler());
     else if (elementTail.equals("##"))
       marshalers.put(elementId, new DoubleArgumentMarshaler());
     else if (elementTail.equals("[*]"))
       marshalers.put(elementId, new StringArrayArgumentMarshaler());
     else
       throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail);
   }
 
   private void validateSchemaElementId(char elementId) throws ArgsException {
     if (!Character.isLetter(elementId))
       throw new ArgsException(INVALID_ARGUMENT_NAME, elementId, null);
   }
 
   private void parseArgumentStrings(List<String> argsList) throws ArgsException
   {
     for (currentArgument = argsList.listIterator(); currentArgument.hasNext();)
     {
       String argString = currentArgument.next();
       if (argString.startsWith("-")) {
         parseArgumentCharacters(argString.substring(1));
       } else {
         currentArgument.previous();
         break;
       }
     }
   }
 
   private void parseArgumentCharacters(String argChars) throws ArgsException {
     for (int i = 0; i < argChars.length(); i++)
       parseArgumentCharacter(argChars.charAt(i));
   }
 
   private void parseArgumentCharacter(char argChar) throws ArgsException {
     ArgumentMarshaler m = marshalers.get(argChar);
     if (m == null) {
       throw new ArgsException(UNEXPECTED_ARGUMENT, argChar, null);
     } else {
       argsFound.add(argChar);
       try {
         m.set(currentArgument);
       } catch (ArgsException e) {
         e.setErrorArgumentId(argChar);
         throw e;
       }
     }
   }
 
   public boolean has(char arg) {
     return argsFound.contains(arg);
   }
 
   public int nextArgument() {
     return currentArgument.nextIndex();
   }
 
   public boolean getBoolean(char arg) {
     return BooleanArgumentMarshaler.getValue(marshalers.get(arg));
   }
 
   public String getString(char arg) {
     return StringArgumentMarshaler.getValue(marshalers.get(arg));
   }
 
   public int getInt(char arg) {
     return IntegerArgumentMarshaler.getValue(marshalers.get(arg));
   }
 
   public double getDouble(char arg) {
     return DoubleArgumentMarshaler.getValue(marshalers.get(arg));
   }
 
   public String[] getStringArray(char arg) {
     return StringArrayArgumentMarshaler.getValue(marshalers.get(arg));
   }
 }
 
 //////////////////
 
 public interface ArgumentMarshaler {
    void set(Iterator<String> currentArgument) throws ArgsException;
 }
 
 ///////////////////
 
 public class BooleanArgumentMarshaler implements ArgumentMarshaler {
    private boolean booleanValue = false;
  
    public void set(Iterator<String> currentArgument) throws ArgsException {
      booleanValue = true;
    }
  
    public static boolean getValue(ArgumentMarshaler am) {
      if (am != null && am instanceof BooleanArgumentMarshaler)
        return ((BooleanArgumentMarshaler) am).booleanValue;
      else
        return false;
    }
  }
 
 ////////////////////
 
 import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;
 
 public class StringArgumentMarshaler implements ArgumentMarshaler {
   private String stringValue = "";
 
   public void set(Iterator<String> currentArgument) throws ArgsException {
     try {
       stringValue = currentArgument.next();
     } catch (NoSuchElementException e) {
       throw new ArgsException(MISSING_STRING);
     }
   }
 
   public static String getValue(ArgumentMarshaler am) {
     if (am != null && am instanceof StringArgumentMarshaler)
       return ((StringArgumentMarshaler) am).stringValue;
     else
       return "";
   }
 }
 
 /////////////////////
 
 import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;
 
 public class IntegerArgumentMarshaler implements ArgumentMarshaler {
   private int intValue = 0;
 
   public void set(Iterator<String> currentArgument) throws ArgsException {
     String parameter = null;
     try {
       parameter = currentArgument.next();
       intValue = Integer.parseInt(parameter);
     } catch (NoSuchElementException e) {
       throw new ArgsException(MISSING_INTEGER);
     } catch (NumberFormatException e) {
       throw new ArgsException(INVALID_INTEGER, parameter);
     }
   }
 
   public static int getValue(ArgumentMarshaler am) {
     if (am != null && am instanceof IntegerArgumentMarshaler)
       return ((IntegerArgumentMarshaler) am).intValue;
     else
       return 0;
   }
 }
 
 ///////////////////////
 
 import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;
 
 public class ArgsException extends Exception {
   private char errorArgumentId = '\0';
   private String errorParameter = null;
   private ErrorCode errorCode = OK;
 
   public ArgsException() {}
 
   public ArgsException(String message) {super(message);}
 
   public ArgsException(ErrorCode errorCode) {
     this.errorCode = errorCode;
   }
 
   public ArgsException(ErrorCode errorCode, String errorParameter) {
     this.errorCode = errorCode;
     this.errorParameter = errorParameter;
   }
 
   public ArgsException(ErrorCode errorCode,
                        char errorArgumentId, String errorParameter) {
     this.errorCode = errorCode;
     this.errorParameter = errorParameter;
     this.errorArgumentId = errorArgumentId;
   }
 
   public char getErrorArgumentId() {
     return errorArgumentId;
   }
 
   public void setErrorArgumentId(char errorArgumentId) {
     this.errorArgumentId = errorArgumentId;
   }
 
   public String getErrorParameter() {
     return errorParameter;
   }
 
   public void setErrorParameter(String errorParameter) {
     this.errorParameter = errorParameter;
   }
 
   public ErrorCode getErrorCode() {
     return errorCode;
   }
 
   public void setErrorCode(ErrorCode errorCode) {
     this.errorCode = errorCode;
   }
 
   public String errorMessage() {
     switch (errorCode) {
       case OK:
         return "TILT: Nie dost�pne.";
       case UNEXPECTED_ARGUMENT:
       return String.format("Nieoczekiwany argument -%c.", errorArgumentId);
       case MISSING_STRING:
       return String.format("Nie mo�na znale�� parametru znakowego dla -%c.",
                            errorArgumentId);
       case INVALID_INTEGER:
       return String.format("Argument -%c oczekuje liczby ca�kowitej, a by� '%s'.",
                             errorArgumentId, errorParameter);
       case MISSING_INTEGER:
         return String.format("Nie mo�na znale�� parametru ca�kowitego dla -%c.",
                              errorArgumentId);
       case INVALID_DOUBLE:
         return String.format("Argument -%c oczekuje liczby double a by� '%s'.",
                               errorArgumentId, errorParameter);
       case MISSING_DOUBLE:
         return String.format("Nie mo�na znale�� parametru double dla -%c.",
                              errorArgumentId);
       case INVALID_ARGUMENT_NAME:
         return String.format("'%c' nie jest prawid�ow� nazw� argumentu.",
                              errorArgumentId);
       case INVALID_ARGUMENT_FORMAT:
         return String.format("'%s' nie jest prawid�owym formatem argumentu.",
                              errorParameter);
     }
     return "";
   }
   
   public enum ErrorCode {
   OK, INVALID_ARGUMENT_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
   MISSING_STRING,
   MISSING_INTEGER, INVALID_INTEGER,
   MISSING_DOUBLE, INVALID_DOUBLE}
 }
 
 ///////////////////////
 
 import java.text.ParseException;
 import java.util.*;
 
 public class Args {
   private String schema;
   private String[] args;
   private boolean valid = true;
   private Set<Character> unexpectedArguments = new TreeSet<Character>();
   private Map<Character, Boolean> booleanArgs =
     new HashMap<Character, Boolean>();
   private Map<Character, String> stringArgs = new HashMap<Character, String>();
   private Map<Character, Integer> intArgs = new HashMap<Character, Integer>();
   private Set<Character> argsFound = new HashSet<Character>();
   private int currentArgument;
   private char errorArgumentId = '\0';
   private String errorParameter = "TILT";
   private ErrorCode errorCode = ErrorCode.OK;
 
   private enum ErrorCode {
     OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}
 
   public Args(String schema, String[] args) throws ParseException {
     this.schema = schema;
     this.args = args;
     valid = parse();
   }
 
   private boolean parse() throws ParseException {
     if (schema.length() == 0 && args.length == 0)
       return true;
     parseSchema();
     try {
       parseArguments();
     } catch (ArgsException e) {
     }
     return valid;
   }
 
   private boolean parseSchema() throws ParseException {
     for (String element : schema.split(",")) {
       if (element.length() > 0) {
         String trimmedElement = element.trim();
         parseSchemaElement(trimmedElement);
       }
     }
     return true;
   }
 
   private void parseSchemaElement(String element) throws ParseException {
     char elementId = element.charAt(0);
     String elementTail = element.substring(1);
     validateSchemaElementId(elementId);
     if (isBooleanSchemaElement(elementTail))
       parseBooleanSchemaElement(elementId);
     else if (isStringSchemaElement(elementTail))
       parseStringSchemaElement(elementId);
     else if (isIntegerSchemaElement(elementTail)) {
       parseIntegerSchemaElement(elementId);
     } else {
       throw new ParseException(
         String.format("Argument: %c ma niew�a�ciwy format: %s.",
                        elementId, elementTail), 0);
     }
   }
 
   private void validateSchemaElementId(char elementId) throws ParseException {
     if (!Character.isLetter(elementId)) {
       throw new ParseException(
         "Z�y znak:" + elementId + "w formacie Args: " + schema, 0);
     }
   }
 
   private void parseBooleanSchemaElement(char elementId) {
     booleanArgs.put(elementId, false);
   }
 
   private void parseIntegerSchemaElement(char elementId) {
     intArgs.put(elementId, 0);
   }
 
   private void parseStringSchemaElement(char elementId) {
     stringArgs.put(elementId, "");
   }
 
   private boolean isStringSchemaElement(String elementTail) {
     return elementTail.equals("*");
   }
 
   private boolean isBooleanSchemaElement(String elementTail) {
     return elementTail.length() == 0;
   }
 
   private boolean isIntegerSchemaElement(String elementTail) {
     return elementTail.equals("#");
   }
 
   private boolean parseArguments() throws ArgsException {
     for (currentArgument = 0; currentArgument < args.length; currentArgument++)
     {
       String arg = args[currentArgument];
       parseArgument(arg);
     }
       return true;
   }
 
   private void parseArgument(String arg) throws ArgsException {
     if (arg.startsWith("-"))
       parseElements(arg);
   }
 
   private void parseElements(String arg) throws ArgsException {
     for (int i = 1; i < arg.length(); i++)
       parseElement(arg.charAt(i));
   }
 
   private void parseElement(char argChar) throws ArgsException {
     if (setArgument(argChar))
       argsFound.add(argChar);
     else {
       unexpectedArguments.add(argChar);
       errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
       valid = false;
     }
   }
 
   private boolean setArgument(char argChar) throws ArgsException {
     if (isBooleanArg(argChar))
       setBooleanArg(argChar, true);
     else if (isStringArg(argChar))
       setStringArg(argChar);
     else if (isIntArg(argChar))
       setIntArg(argChar);
     else
       return false;
     return true;
   }
 
   private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}
 
   private void setIntArg(char argChar) throws ArgsException {
     currentArgument++;
     String parameter = null;
     try {
       parameter = args[currentArgument];
       intArgs.put(argChar, new Integer(parameter));
     } catch (ArrayIndexOutOfBoundsException e) {
       valid = false;
       errorArgumentId = argChar;
       errorCode = ErrorCode.MISSING_INTEGER;
       throw new ArgsException();
     } catch (NumberFormatException e) {
       valid = false;
       errorArgumentId = argChar;
       errorParameter = parameter;
       errorCode = ErrorCode.INVALID_INTEGER;
       throw new ArgsException();
     }
   }
 
   private void setStringArg(char argChar) throws ArgsException {
     currentArgument++;
     try {
       stringArgs.put(argChar, args[currentArgument]);
     } catch (ArrayIndexOutOfBoundsException e) {
       valid = false;
       errorArgumentId = argChar;
       errorCode = ErrorCode.MISSING_STRING;
       throw new ArgsException();
     }
   }
 
   private boolean isStringArg(char argChar) {
     return stringArgs.containsKey(argChar);
   }
 
   private void setBooleanArg(char argChar, boolean value) {
     booleanArgs.put(argChar, value);
   }
 
   private boolean isBooleanArg(char argChar) {
     return booleanArgs.containsKey(argChar);
   }
 
   public int cardinality() {
     return argsFound.size();
   }
 
   public String usage() {
     if (schema.length() > 0)
       return "-[" + schema + "]";
     else
       return "";
   }
 
   public String errorMessage() throws Exception {
     switch (errorCode) {
       case OK:
         throw new Exception("TILT: Nie dost�pne.");
       case UNEXPECTED_ARGUMENT:
         return unexpectedArgumentMessage();
       case MISSING_STRING:
         return String.format("Nie mo�na znale�� parametru znakowego dla -%c.",
                              errorArgumentId);
       case INVALID_INTEGER:
         return String.format("Argument -%c oczekuje liczby ca�kowitej, a by� '%s'.",
                              errorArgumentId, errorParameter);
       case MISSING_INTEGER:
         return String.format("Nie mo�na znale�� parametru ca�kowitego dla -%c.",
                              errorArgumentId);
     }
     return "";
   }
 
   private String unexpectedArgumentMessage() {
     StringBuffer message = new StringBuffer("Argument(y) -");
     for (char c : unexpectedArguments) {
       message.append(c);
     }
     message.append(" nieoczekiwany.");
     return message.toString();
   }
 
   private boolean falseIfNull(Boolean b) {
     return b != null && b;
   }
 
   private int zeroIfNull(Integer i) {
     return i == null ? 0 : i;
   }
 
   private String blankIfNull(String s) {
     return s == null ? "" : s;
   }
 
   public String getString(char arg) {
     return blankIfNull(stringArgs.get(arg));
   }
 
   public int getInt(char arg) {
     return zeroIfNull(intArgs.get(arg));
   }
 
   public boolean getBoolean(char arg) {
     return falseIfNull(booleanArgs.get(arg));
   }
 
   public boolean has(char arg) {
     return argsFound.contains(arg);
   }
 
   public boolean isValid() {
     return valid;
   }
 
   private class ArgsException extends Exception {
   }
 }
 
 ////////////////////////
 
 package com.objectmentor.utilities.getopts;
 
 import java.util.*;
 
 public class Args {
   private String schema;
   private String[] args;
   private boolean valid;
   private Set<Character> unexpectedArguments = new TreeSet<Character>();
   private Map<Character, Boolean> booleanArgs =
     new HashMap<Character, Boolean>();
   private int numberOfArguments = 0;
 
   public Args(String schema, String[] args) {
     this.schema = schema;
     this.args = args;
     valid = parse();
   }
 
   public boolean isValid() {
     return valid;
   }
 
   private boolean parse() {
     if (schema.length() == 0 && args.length == 0)
       return true;
     parseSchema();
     parseArguments();
     return unexpectedArguments.size() == 0;
   }
 
   private boolean parseSchema() {
     for (String element : schema.split(",")) {
       parseSchemaElement(element);
     }
     return true;
   }
 
   private void parseSchemaElement(String element) {
     if (element.length() == 1) {
       parseBooleanSchemaElement(element);
     }
   }
 
   private void parseBooleanSchemaElement(String element) {
     char c = element.charAt(0);
     if (Character.isLetter(c)) {
       booleanArgs.put(c, false);
     }
   }
 
   private boolean parseArguments() {
     for (String arg : args)
       parseArgument(arg);
     return true;
   }
 
   private void parseArgument(String arg) {
     if (arg.startsWith("-"))
       parseElements(arg);
   }
 
   private void parseElements(String arg) {
     for (int i = 1; i < arg.length(); i++)
       parseElement(arg.charAt(i));
   }
 
   private void parseElement(char argChar) {
     if (isBoolean(argChar)) {
       numberOfArguments++;
       setBooleanArg(argChar, true);
     } else
       unexpectedArguments.add(argChar);
   }
 
   private void setBooleanArg(char argChar, boolean value) {
     booleanArgs.put(argChar, value);
   }
 
   private boolean isBoolean(char argChar) {
     return booleanArgs.containsKey(argChar);
   }
 
   public int cardinality() {
     return numberOfArguments;
   }
 
   public String usage() {
     if (schema.length() > 0)
       return "-["+schema+"]";
     else
       return "";
   }
 
   public String errorMessage() {
     if (unexpectedArguments.size() > 0) {
       return unexpectedArgumentMessage();
     } else
       return "";
   }
 
   private String unexpectedArgumentMessage() {
     StringBuffer message = new StringBuffer("Argument(y) -");
     for (char c : unexpectedArguments) {
       message.append(c);
     }
     message.append(" nieoczekiwany.");
     return message.toString();
   }
 
   public boolean getBoolean(char arg) {
     return booleanArgs.get(arg);
   }
 }
 
 //////////////////
 
 
 package com.objectmentor.utilities.getopts;
 
 import java.text.ParseException;
 import java.util.*;
 
 public class Args {
   private String schema;
   private String[] args;
   private boolean valid = true;
   private Set<Character> unexpectedArguments = new TreeSet<Character>();
   private Map<Character, Boolean> booleanArgs =
     new HashMap<Character, Boolean>();
   private Map<Character, String> stringArgs =
     new HashMap<Character, String>();
   private Set<Character> argsFound = new HashSet<Character>();
   private int currentArgument;
   private char errorArgument = '\0';
 
   enum ErrorCode {
     OK, MISSING_STRING}
 
   private ErrorCode errorCode = ErrorCode.OK;
 
   public Args(String schema, String[] args) throws ParseException {
     this.schema = schema;
     this.args = args;
     valid = parse();
   }
 
   private boolean parse() throws ParseException {
     if (schema.length() == 0 && args.length == 0)
       return true;
     parseSchema();
     parseArguments();
     return valid;
   }
 
   private boolean parseSchema() throws ParseException {
     for (String element : schema.split(",")) {
       if (element.length() > 0) {
         String trimmedElement = element.trim();
         parseSchemaElement(trimmedElement);
       }
     }
     return true;
   }
 
   private void parseSchemaElement(String element) throws ParseException {
     char elementId = element.charAt(0);
     String elementTail = element.substring(1);
     validateSchemaElementId(elementId);
     if (isBooleanSchemaElement(elementTail))
       parseBooleanSchemaElement(elementId);
     else if (isStringSchemaElement(elementTail))
       parseStringSchemaElement(elementId);
   }
 
   private void validateSchemaElementId(char elementId) throws ParseException {
     if (!Character.isLetter(elementId)) {
       throw new ParseException(
         "Z�y znak:" + elementId + "w formacie Args: " + schema, 0);
     }
   }
 
   private void parseStringSchemaElement(char elementId) {
     stringArgs.put(elementId, "");
   }
 
   private boolean isStringSchemaElement(String elementTail) {
     return elementTail.equals("*");
   }
 
   private boolean isBooleanSchemaElement(String elementTail) {
     return elementTail.length() == 0;
   }
 
   private void parseBooleanSchemaElement(char elementId) {
     booleanArgs.put(elementId, false);
   }
 
   private boolean parseArguments() {
     for (currentArgument = 0; currentArgument < args.length; currentArgument++)
     {
       String arg = args[currentArgument];
       parseArgument(arg);
     }
     return true;
   }
 
   private void parseArgument(String arg) {
     if (arg.startsWith("-"))
       parseElements(arg);
   }
 
   private void parseElements(String arg) {
     for (int i = 1; i < arg.length(); i++)
       parseElement(arg.charAt(i));
   }
 
   private void parseElement(char argChar) {
     if (setArgument(argChar))
       argsFound.add(argChar);
     else {
       unexpectedArguments.add(argChar);
       valid = false;
     }
   }
 
   private boolean setArgument(char argChar) {
     boolean set = true;
     if (isBoolean(argChar))
       setBooleanArg(argChar, true);
     else if (isString(argChar))
       setStringArg(argChar, "");
     else
       set = false;
     return set;
   }
 
   private void setStringArg(char argChar, String s) {
     currentArgument++;
     try {
       stringArgs.put(argChar, args[currentArgument]);
     } catch (ArrayIndexOutOfBoundsException e) {
       valid = false;
       errorArgument = argChar;
       errorCode = ErrorCode.MISSING_STRING;
     }
   }
 
   private boolean isString(char argChar) {
     return stringArgs.containsKey(argChar);
   }
 
   private void setBooleanArg(char argChar, boolean value) {
     booleanArgs.put(argChar, value);
   }
 
   private boolean isBoolean(char argChar) {
     return booleanArgs.containsKey(argChar);
   }
 
   public int cardinality() {
     return argsFound.size();
   }
 
   public String usage() {
     if (schema.length() > 0)
       return "-[" + schema + "]";
     else
       return "";
   }
 
   public String errorMessage() throws Exception {
     if (unexpectedArguments.size() > 0) {
       return unexpectedArgumentMessage();
     } else
       switch (errorCode) {
         case MISSING_STRING:
           return String.format("Nie mo�na znale�� parametru znakowego dla -%c.",
                                errorArgument);
         case OK:
           throw new Exception("TILT: Nie dost�pne.");
       }
     return "";
   }
 
   private String unexpectedArgumentMessage() {
     StringBuffer message = new StringBuffer("Argument(y) -");
     for (char c : unexpectedArguments) {
       message.append(c);
     }
     message.append(" nieoczekiwany.");
     return message.toString();
   }
 
   public boolean getBoolean(char arg) {
     return falseIfNull(booleanArgs.get(arg));
   }
 
   private boolean falseIfNull(Boolean b) {
     return b == null ? false : b;
   }
 
   public String getString(char arg) {
     return blankIfNull(stringArgs.get(arg));
   }
 
   private String blankIfNull(String s) {
     return s == null ? "" : s;
   }
 
   public boolean has(char arg) {
     return argsFound.contains(arg);
   }
 
   public boolean isValid() {
     return valid;
   }
 }
 
 //////////////
 
 private class ArgumentMarshaler {
    private boolean booleanValue = false;
  
    public void setBoolean(boolean value) {
      booleanValue = value;
    }
  
    public boolean getBoolean() {return booleanValue;}
    }
  
    private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    }
  
    private class StringArgumentMarshaler extends ArgumentMarshaler {
    }
  
    private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    }
  }
 
 /////////////////
 
 package com.objectmentor.utilities.getopts;
 
 import java.text.ParseException;
 import java.util.*;
 
 public class Args {
   private String schema;
   private String[] args;
   private boolean valid = true;
   private Set<Character> unexpectedArguments = new TreeSet<Character>();
   private Map<Character, ArgumentMarshaler> marshalers =
     new HashMap<Character, ArgumentMarshaler>();
   private Set<Character> argsFound = new HashSet<Character>();
   private int currentArgument;
   private char errorArgumentId = '\0';
   private String errorParameter = "TILT";
   private ErrorCode errorCode = ErrorCode.OK;
 
   private enum ErrorCode {
     OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}
 
   public Args(String schema, String[] args) throws ParseException {
     this.schema = schema;
     this.args = args;
     valid = parse();
   }
 
   private boolean parse() throws ParseException {
     if (schema.length() == 0 && args.length == 0)
       return true;
     parseSchema();
     try {
       parseArguments();
     } catch (ArgsException e) {
     }
     return valid;
   }
 
   private boolean parseSchema() throws ParseException {
     for (String element : schema.split(",")) {
       if (element.length() > 0) {
         String trimmedElement = element.trim();
         parseSchemaElement(trimmedElement);
       }
     }
     return true;
   }
 
   private void parseSchemaElement(String element) throws ParseException {
     char elementId = element.charAt(0);
     String elementTail = element.substring(1);
     validateSchemaElementId(elementId);
     if (isBooleanSchemaElement(elementTail))
       marshalers.put(elementId, new BooleanArgumentMarshaler());
     else if (isStringSchemaElement(elementTail))
       marshalers.put(elementId, new StringArgumentMarshaler());
     else if (isIntegerSchemaElement(elementTail)) {
       marshalers.put(elementId, new IntegerArgumentMarshaler());
     } else {
       throw new ParseException(String.format(
       "Argument: %c ma niew�a�ciwy format: %s.", elementId, elementTail), 0);
     }
   }
 
   private void validateSchemaElementId(char elementId) throws ParseException {
     if (!Character.isLetter(elementId)) {
       throw new ParseException(
         "Z�y znak:" + elementId + "w formacie Args: " + schema, 0);
     }
   }
 
   private boolean isStringSchemaElement(String elementTail) {
     return elementTail.equals("*");
   }
 
   private boolean isBooleanSchemaElement(String elementTail) {
     return elementTail.length() == 0;
   }
 
   private boolean isIntegerSchemaElement(String elementTail) {
     return elementTail.equals("#");
   }
 
   private boolean parseArguments() throws ArgsException {
     for (currentArgument=0; currentArgument<args.length; currentArgument++) {
       String arg = args[currentArgument];
       parseArgument(arg);
     }
     return true;
   }
 
   private void parseArgument(String arg) throws ArgsException {
     if (arg.startsWith("-"))
       parseElements(arg);
   }
 
   private void parseElements(String arg) throws ArgsException {
     for (int i = 1; i < arg.length(); i++)
       parseElement(arg.charAt(i));
   }
 
   private void parseElement(char argChar) throws ArgsException {
     if (setArgument(argChar))
       argsFound.add(argChar);
     else {
       unexpectedArguments.add(argChar);
       errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
       valid = false;
     }
   }
 
   private boolean setArgument(char argChar) throws ArgsException {
     ArgumentMarshaler m = marshalers.get(argChar);
     try {
       if (m instanceof BooleanArgumentMarshaler)
         setBooleanArg(m);
       else if (m instanceof StringArgumentMarshaler)
         setStringArg(m);
       else if (m instanceof IntegerArgumentMarshaler)
         setIntArg(m);
       else
         return false;
     } catch (ArgsException e) {
       valid = false;
       errorArgumentId = argChar;
       throw e;
     }
     return true;
   }
 
   private void setIntArg(ArgumentMarshaler m) throws ArgsException {
     currentArgument++;
     String parameter = null;
     try {
       parameter = args[currentArgument];
       m.set(parameter);
     } catch (ArrayIndexOutOfBoundsException e) {
       errorCode = ErrorCode.MISSING_INTEGER;
       throw new ArgsException();
     } catch (ArgsException e) {
       errorParameter = parameter;
       errorCode = ErrorCode.INVALID_INTEGER;
       throw e;
     }
   }
 
   private void setStringArg(ArgumentMarshaler m) throws ArgsException {
     currentArgument++;
     try {
       m.set(args[currentArgument]);
     } catch (ArrayIndexOutOfBoundsException e) {
       errorCode = ErrorCode.MISSING_STRING;
       throw new ArgsException();
     }
   }
 
   private void setBooleanArg(ArgumentMarshaler m) {
     try {
       m.set("true");
     } catch (ArgsException e) {
     }
   }
 
   public int cardinality() {
     return argsFound.size();
   }
 
   public String usage() {
     if (schema.length() > 0)
       return "-[" + schema + "]";
     else
       return "";
   }
 
   public String errorMessage() throws Exception {
     switch (errorCode) {
       case OK:
         throw new Exception("TILT: Nie dost�pne.");
       case UNEXPECTED_ARGUMENT:
         return unexpectedArgumentMessage();
       case MISSING_STRING:
         return String.format("Nie mo�na znale�� parametru znakowego dla -%c.",
                              errorArgumentId);
       case INVALID_INTEGER:
         return String.format("Argument -%c oczekuje liczby ca�kowitej, a by� '%s'.",
                              errorArgumentId, errorParameter);
       case MISSING_INTEGER:
         return String.format("Nie mo�na znale�� parametru ca�kowitego dla -%c.",
                              errorArgumentId);
     }
     return "";
   }
 
   private String unexpectedArgumentMessage() {
     StringBuffer message = new StringBuffer("Argument(y) -");
     for (char c : unexpectedArguments) {
       message.append(c);
     }
     message.append(" nieoczekiwany.");
     return message.toString();
   }
 
   public boolean getBoolean(char arg) {
     Args.ArgumentMarshaler am = marshalers.get(arg);
       boolean b = false;
     try {
       b = am != null && (Boolean) am.get();
     } catch (ClassCastException e) {
       b = false;
     }
     return b;
   }
 
   public String getString(char arg) {
       Args.ArgumentMarshaler am = marshalers.get(arg);
     try {
       return am == null ? "" : (String) am.get();
     } catch (ClassCastException e) {
       return "";
     }
   }
 
   public int getInt(char arg) {
     Args.ArgumentMarshaler am = marshalers.get(arg);
     try {
       return am == null ? 0 : (Integer) am.get();
     } catch (Exception e) {
       return 0;
     }
   }
 
   public boolean has(char arg) {
     return argsFound.contains(arg);
   }
 
   public boolean isValid() {
     return valid;
   }
 
   private class ArgsException extends Exception {
   }
     private abstract class ArgumentMarshaler {
     public abstract void set(String s) throws ArgsException;
     public abstract Object get();
   }
 
   private class BooleanArgumentMarshaler extends ArgumentMarshaler {
     private boolean booleanValue = false;
 
     public void set(String s) {
       booleanValue = true;
     }
 
     public Object get() {
       return booleanValue;
     }
   }
 
   private class StringArgumentMarshaler extends ArgumentMarshaler {
     private String stringValue = "";
 
     public void set(String s) {
       stringValue = s;
     }
     public Object get() {
       return stringValue;
     }
   }
 
   private class IntegerArgumentMarshaler extends ArgumentMarshaler {
     private int intValue = 0;
 
     public void set(String s) throws ArgsException {
       try {
         intValue = Integer.parseInt(s);
       } catch (NumberFormatException e) {
         throw new ArgsException();
       }
     }
 
     public Object get() {
       return intValue;
     }
   }
 }
 
 /////////////////////////
 
 package com.objectmentor.utilities.args;
 
 import junit.framework.TestCase;
 
 public class ArgsTest extends TestCase {
   public void testCreateWithNoSchemaOrArguments() throws Exception {
     Args args = new Args("", new String[0]);
     assertEquals(0, args.cardinality());
   }
 
   public void testWithNoSchemaButWithOneArgument() throws Exception {
     try {
       new Args("", new String[]{"-x"});
       fail();
     } catch (ArgsException e) {
       assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
       e.getErrorCode());
       assertEquals('x', e.getErrorArgumentId());
     }
   }
 
   public void testWithNoSchemaButWithMultipleArguments() throws Exception {
     try {
       new Args("", new String[]{"-x", "-y"});
       fail();
     } catch (ArgsException e) {
       assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
       e.getErrorCode());
       assertEquals('x', e.getErrorArgumentId());
     }
   }
 
   public void testNonLetterSchema() throws Exception {
     try {
       new Args("*", new String[]{});
       fail("Konstruktor Args powinien zglosi� wyj�tek");
     } catch (ArgsException e) {
       assertEquals(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
       e.getErrorCode());
       assertEquals('*', e.getErrorArgumentId());
     }
   }
 
   public void testInvalidArgumentFormat() throws Exception {
     try {
       new Args("f~", new String[]{});
       fail("Konstruktor Args powinien zglosi� wyj�tek");
     } catch (ArgsException e) {
       assertEquals(ArgsException.ErrorCode.INVALID_FORMAT, e.getErrorCode());
       assertEquals('f', e.getErrorArgumentId());
     }
   }
 
   public void testSimpleBooleanPresent() throws Exception {
     Args args = new Args("x", new String[]{"-x"});
     assertEquals(1, args.cardinality());
     assertEquals(true, args.getBoolean('x'));
   }
 
   public void testSimpleStringPresent() throws Exception {
     Args args = new Args("x*", new String[]{"-x", "param"});
     assertEquals(1, args.cardinality());
     assertTrue(args.has('x'));
     assertEquals("param", args.getString('x'));
   }
 
   public void testMissingStringArgument() throws Exception {
     try {
       new Args("x*", new String[]{"-x"});
       fail();
     } catch (ArgsException e) {
       assertEquals(ArgsException.ErrorCode.MISSING_STRING, e.getErrorCode());
       assertEquals('x', e.getErrorArgumentId());
     }
   }
 
   public void testSpacesInFormat() throws Exception {
     Args args = new Args("x, y", new String[]{"-xy"});
     assertEquals(2, args.cardinality());
     assertTrue(args.has('x'));
     assertTrue(args.has('y'));
   }
 
   public void testSimpleIntPresent() throws Exception {
     Args args = new Args("x#", new String[]{"-x", "42"});
     assertEquals(1, args.cardinality());
     assertTrue(args.has('x'));
     assertEquals(42, args.getInt('x'));
   }
 
   public void testInvalidInteger() throws Exception {
     try {
       new Args("x#", new String[]{"-x", "Czterdzie�ci dwa"});
       fail();
     } catch (ArgsException e) {
       assertEquals(ArgsException.ErrorCode.INVALID_INTEGER, e.getErrorCode());
       assertEquals('x', e.getErrorArgumentId());
       assertEquals("Czterdzie�ci dwa", e.getErrorParameter());
     }
   }
 
   public void testMissingInteger() throws Exception {
     try {
       new Args("x#", new String[]{"-x"});
       fail();
     } catch (ArgsException e) {
       assertEquals(ArgsException.ErrorCode.MISSING_INTEGER, e.getErrorCode());
       assertEquals('x', e.getErrorArgumentId());
     }
   }
 
   public void testSimpleDoublePresent() throws Exception {
     Args args = new Args("x##", new String[]{"-x", "42.3"});
     assertEquals(1, args.cardinality());
     assertTrue(args.has('x'));
     assertEquals(42.3, args.getDouble('x'), .001);
   }
 
   public void testInvalidDouble() throws Exception {
     try {
       new Args("x##", new String[]{"-x", "Czterdzie�ci dwa"});
       fail();
     } catch (ArgsException e) {
       assertEquals(ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode());
       assertEquals('x', e.getErrorArgumentId());
       assertEquals("Czterdzie�ci dwa", e.getErrorParameter());
     }
   }
 
   public void testMissingDouble() throws Exception {
     try {
       new Args("x##", new String[]{"-x"});
       fail();
     } catch (ArgsException e) {
       assertEquals(ArgsException.ErrorCode.MISSING_DOUBLE, e.getErrorCode());
       assertEquals('x', e.getErrorArgumentId());
     }
   }
 }
 
 //////////////////////
 
 public class ArgsExceptionTest extends TestCase {
    public void testUnexpectedMessage() throws Exception {
      ArgsException e =
        new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                          'x', null);
      assertEquals("Argument -x nieoczekiwany.", e.errorMessage());
    }
  
    public void testMissingStringMessage() throws Exception {
      ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_STRING,
                                          'x', null);
      assertEquals("Nie mo�na znale�� parametru znakowego dla -x.", e.errorMessage());
    }
  
    public void testInvalidIntegerMessage() throws Exception {
      ArgsException e =
      new ArgsException(ArgsException.ErrorCode.INVALID_INTEGER,
                        'x', "Czterdzie�ci dwa");
      assertEquals("Argument -x oczekuje liczby ca�kowitej 'Czterdzie�ci dwa'.",
      e.errorMessage());
    }
  
    public void testMissingIntegerMessage() throws Exception {
      ArgsException e =
        new ArgsException(ArgsException.ErrorCode.MISSING_INTEGER, 'x', null);
        assertEquals("Nie mo�na znale�� parametru ca�kowitego dla -x.", e.errorMessage());
    }
  
    public void testInvalidDoubleMessage() throws Exception {
      ArgsException e = new ArgsException(ArgsException.ErrorCode.INVALID_DOUBLE,
                                          'x', "Czterdzie�ci dwa");
      assertEquals("Argument -x oczekuje liczby double a by� 'Czterdzie�ci dwa'.",
      e.errorMessage());
    }
  
    public void testMissingDoubleMessage() throws Exception {
      ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_DOUBLE,
                                          'x', null);
      assertEquals("Nie mo�na znale�� parametru double dla -x.", e.errorMessage());
    }
  }
 
 ////////////////////////////
 
 public class ArgsException extends Exception {
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;
  
    public ArgsException() {}
  
    public ArgsException(String message) {super(message);}
  
    public ArgsException(ErrorCode errorCode) {
      this.errorCode = errorCode;
    }
  
    public ArgsException(ErrorCode errorCode, String errorParameter) {
      this.errorCode = errorCode;
      this.errorParameter = errorParameter;
    }
  
    public ArgsException(ErrorCode errorCode, char errorArgumentId,
                         String errorParameter) {
      this.errorCode = errorCode;
      this.errorParameter = errorParameter;
      this.errorArgumentId = errorArgumentId;
    }
  
    public char getErrorArgumentId() {
      return errorArgumentId;
    }
  
    public void setErrorArgumentId(char errorArgumentId) {
      this.errorArgumentId = errorArgumentId;
    }
  
    public String getErrorParameter() {
      return errorParameter;
    }
  
    public void setErrorParameter(String errorParameter) {
      this.errorParameter = errorParameter;
    }
  
    public ErrorCode getErrorCode() {
      return errorCode;
    }
  
    public void setErrorCode(ErrorCode errorCode) {
      this.errorCode = errorCode;
    }
  
    public String errorMessage() throws Exception {
      switch (errorCode) {
        case OK:
          throw new Exception("TILT: Nie dost�pne.");
        case UNEXPECTED_ARGUMENT:
          return String.format("Nieoczekiwany argument -%c.", errorArgumentId);
        case MISSING_STRING:
          return String.format("Nie mo�na znale�� parametru znakowego dla -%c.",
                               errorArgumentId);
        case INVALID_INTEGER:
          return String.format("Argument -%c oczekuje liczby ca�kowitej, a by� '%s'.",
                               errorArgumentId, errorParameter);
        case MISSING_INTEGER:
          return String.format("Nie mo�na znale�� parametru ca�kowitego dla -%c.",
                               errorArgumentId);
        case INVALID_DOUBLE:
          return String.format("Argument -%c oczekuje liczby double a by� '%s'.",
                               errorArgumentId, errorParameter);
        case MISSING_DOUBLE:
          return String.format("Nie mo�na znale�� parametru double dla -%c.",
                               errorArgumentId);
      }
      return "";
    }
  
    public enum ErrorCode {
      OK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
      MISSING_STRING,
      MISSING_INTEGER, INVALID_INTEGER,
      MISSING_DOUBLE, INVALID_DOUBLE}
  }
 
 ///////////////////
 
 public class Args {
    private String schema;
    private Map<Character, ArgumentMarshaler> marshalers =
      new HashMap<Character, ArgumentMarshaler>();
    private Set<Character> argsFound = new HashSet<Character>();
    private Iterator<String> currentArgument;
    private List<String> argsList;
  
    public Args(String schema, String[] args) throws ArgsException {
      this.schema = schema;
      argsList = Arrays.asList(args);
      parse();
    }
  
    private void parse() throws ArgsException {
      parseSchema();
      parseArguments();
    }
  
    private boolean parseSchema() throws ArgsException {
      for (String element : schema.split(",")) {
        if (element.length() > 0) {
          parseSchemaElement(element.trim());
        }
      }
      return true;
    }
  
    private void parseSchemaElement(String element) throws ArgsException {
      char elementId = element.charAt(0);
      String elementTail = element.substring(1);
      validateSchemaElementId(elementId);
      if (elementTail.length() == 0)
        marshalers.put(elementId, new BooleanArgumentMarshaler());
      else if (elementTail.equals("*"))
        marshalers.put(elementId, new StringArgumentMarshaler());
      else if (elementTail.equals("#"))
        marshalers.put(elementId, new IntegerArgumentMarshaler());
      else if (elementTail.equals("##"))
        marshalers.put(elementId, new DoubleArgumentMarshaler());
      else
        throw new ArgsException(ArgsException.ErrorCode.INVALID_FORMAT,
                                elementId, elementTail);
    }
  
    private void validateSchemaElementId(char elementId) throws ArgsException {
      if (!Character.isLetter(elementId)) {
        throw new ArgsException(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
                                elementId, null);
      }
    }
  
    private void parseArguments() throws ArgsException {
      for (currentArgument = argsList.iterator(); currentArgument.hasNext();) {
        String arg = currentArgument.next();
        parseArgument(arg);
      }
    }
  
    private void parseArgument(String arg) throws ArgsException {
      if (arg.startsWith("-"))
        parseElements(arg);
    }
  
    private void parseElements(String arg) throws ArgsException {
      for (int i = 1; i < arg.length(); i++)
        parseElement(arg.charAt(i));
    }
  
    private void parseElement(char argChar) throws ArgsException {
      if (setArgument(argChar))
        argsFound.add(argChar);
      else {
        throw new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                                argChar, null);
      }
    }
  
    private boolean setArgument(char argChar) throws ArgsException {
      ArgumentMarshaler m = marshalers.get(argChar);
      if (m == null)
        return false;
      try {
        m.set(currentArgument);
        return true;
      } catch (ArgsException e) {
        e.setErrorArgumentId(argChar);
        throw e;
      }
    }
  
    public int cardinality() {
      return argsFound.size();
    }
  
    public String usage() {
      if (schema.length() > 0)
        return "-[" + schema + "]";
      else
        return "";
    }
  
    public boolean getBoolean(char arg) {
      ArgumentMarshaler am = marshalers.get(arg);
      boolean b = false;
      try {
        b = am != null && (Boolean) am.get();
      } catch (ClassCastException e) {
        b = false;
      }
      return b;
    }
  
    public String getString(char arg) {
      ArgumentMarshaler am = marshalers.get(arg);
      try {
        return am == null ? "" : (String) am.get();
      } catch (ClassCastException e) {
        return "";
      }
    }
  
    public int getInt(char arg) {
      ArgumentMarshaler am = marshalers.get(arg);
      try {
        return am == null ? 0 : (Integer) am.get();
      } catch (Exception e) {
        return 0;
      }
    }
  
    public double getDouble(char arg) {
      ArgumentMarshaler am = marshalers.get(arg);
      try {
        return am == null ? 0 : (Double) am.get();
      } catch (Exception e) {
        return 0.0;
      }
    }
  
    public boolean has(char arg) {
      return argsFound.contains(arg);
    }
  }
 
 //////////////////////////
 
 package junit.tests.framework;
 
 import junit.framework.ComparisonCompactor;
 import junit.framework.TestCase;
 
 public class ComparisonCompactorTest extends TestCase {
 
   public void testMessage() {
     String failure= new ComparisonCompactor(0, "b", "c").compact("a");
     assertTrue("a oczekiwane:<[b]> a by�o:<[c]>".equals(failure));
   }
 
   public void testStartSame() {
     String failure= new ComparisonCompactor(1, "ba", "bc").compact(null);
     assertEquals("oczekiwane:<b[a]> a by�o:<b[c]>", failure);
   }
 
   public void testEndSame() {
     String failure= new ComparisonCompactor(1, "ab", "cb").compact(null);
     assertEquals("oczekiwane:<[a]b> a by�o:<[c]b>", failure);
   }
 
   public void testSame() {
     String failure= new ComparisonCompactor(1, "ab", "ab").compact(null);
     assertEquals("oczekiwane:<ab> a by�o:<ab>", failure);
   }
 
   public void testNoContextStartAndEndSame() {
     String failure= new ComparisonCompactor(0, "abc", "adc").compact(null);
     assertEquals("oczekiwane:<...[b]...> a by�o:<...[d]...>", failure);
   }
 
   public void testStartAndEndContext() {
     String failure= new ComparisonCompactor(1, "abc", "adc").compact(null);
     assertEquals("oczekiwane:<a[b]c> a by�o:<a[d]c>", failure);
   }
 
   public void testStartAndEndContextWithEllipses() {
     String failure=
       new ComparisonCompactor(1, "abcde", "abfde").compact(null);
     assertEquals("oczekiwane:<...b[c]d...> a by�o:<...b[f]d...>", failure);
   }
 
   public void testComparisonErrorStartSameComplete() {
     String failure= new ComparisonCompactor(2, "ab", "abc").compact(null);
     assertEquals("oczekiwane:<ab[]> a by�o:<ab[c]>", failure);
   }
 
   public void testComparisonErrorEndSameComplete() {
     String failure= new ComparisonCompactor(0, "bc", "abc").compact(null);
     assertEquals("oczekiwane:<[]...> a by�o:<[a]...>", failure);
   }
 
   public void testComparisonErrorEndSameCompleteContext() {
     String failure= new ComparisonCompactor(2, "bc", "abc").compact(null);
     assertEquals("oczekiwane:<[]bc> a by�o:<[a]bc>", failure);
   }
 
   public void testComparisonErrorOverlapingMatches() {
     String failure= new ComparisonCompactor(0, "abc", "abbc").compact(null);
     assertEquals("oczekiwane:<...[]...> a by�o:<...[b]...>", failure);
   }
 
   public void testComparisonErrorOverlapingMatchesContext() {
     String failure= new ComparisonCompactor(2, "abc", "abbc").compact(null);
     assertEquals("oczekiwane:<ab[]c> a by�o:<ab[b]c>", failure);
   }
 
   public void testComparisonErrorOverlapingMatches2() {
     String failure= new ComparisonCompactor(0, "abcdde", "abcde").compact(null);
     assertEquals("oczekiwane:<...[d]...> a by�o:<...[]...>", failure);
   }
 
   public void testComparisonErrorOverlapingMatches2Context() {
     String failure=
       new ComparisonCompactor(2, "abcdde", "abcde").compact(null);
     assertEquals("oczekiwane:<...cd[d]e> a by�o:<...cd[]e>", failure);
   }
 
   public void testComparisonErrorWithActualNull() {
     String failure= new ComparisonCompactor(0, "a", null).compact(null);
     assertEquals("oczekiwane:<a> a by�o:<null>", failure);
   }
 
   public void testComparisonErrorWithActualNullContext() {
     String failure= new ComparisonCompactor(2, "a", null).compact(null);
     assertEquals("oczekiwane:<a> a by�o:<null>", failure);
   }
 
   public void testComparisonErrorWithExpectedNull() {
     String failure= new ComparisonCompactor(0, null, "a").compact(null);
     assertEquals("oczekiwane:<null> a by�o:<a>", failure);
   }
 
   public void testComparisonErrorWithExpectedNullContext() {
     String failure= new ComparisonCompactor(2, null, "a").compact(null);
     assertEquals("oczekiwane:<null> a by�o:<a>", failure);
   }
 
   public void testBug609972() {
     String failure= new ComparisonCompactor(10, "S&P500", "0").compact(null);
     assertEquals("oczekiwane:<[S&P50]0> a by�o:<[]0>", failure);
   }
 }
 
 /////////////////////////
 
 package junit.framework;
 
 public class ComparisonCompactor {
 
   private static final String ELLIPSIS = "...";
   private static final String DELTA_END = "]";
   private static final String DELTA_START = "[";
 
   private int fContextLength;
   private String fExpected;
   private String fActual;
   private int fPrefix;
   private int fSuffix;
 
   public ComparisonCompactor(int contextLength,
                              String expected,
                              String actual) {
     fContextLength = contextLength;
     fExpected = expected;
     fActual = actual;
   }
 
   public String compact(String message) {
     if (fExpected == null || fActual == null || areStringsEqual())
       return Assert.format(message, fExpected, fActual);
 
     findCommonPrefix();
     findCommonSuffix();
     String expected = compactString(fExpected);
     String actual = compactString(fActual);
     return Assert.format(message, expected, actual);
   }
 
   private String compactString(String source) {
     String result = DELTA_START +
                       source.substring(fPrefix, source.length() -
                         fSuffix + 1) + DELTA_END;
     if (fPrefix > 0)
       result = computeCommonPrefix() + result;
     if (fSuffix > 0)
       result = result + computeCommonSuffix();
     return result;
   }
 
   private void findCommonPrefix() {
     fPrefix = 0;
     int end = Math.min(fExpected.length(), fActual.length());
     for (; fPrefix < end; fPrefix++) {
       if (fExpected.charAt(fPrefix) != fActual.charAt(fPrefix))
         break;
     }
   }
 
   private void findCommonSuffix() {
     int expectedSuffix = fExpected.length() - 1;
     int actualSuffix = fActual.length() - 1;
     for (;
          actualSuffix >= fPrefix && expectedSuffix >= fPrefix;
           actualSuffix--, expectedSuffix--) {
       if (fExpected.charAt(expectedSuffix) != fActual.charAt(actualSuffix))
         break;
     }
     fSuffix = fExpected.length() - expectedSuffix;
   }
 
   private String computeCommonPrefix() {
     return (fPrefix > fContextLength ? ELLIPSIS : "") +
              fExpected.substring(Math.max(0, fPrefix - fContextLength),
                                   fPrefix);
   }
 
   private String computeCommonSuffix() {
     int end = Math.min(fExpected.length() - fSuffix + 1 + fContextLength,
     fExpected.length());
     return fExpected.substring(fExpected.length() - fSuffix + 1, end) +
            (fExpected.length() - fSuffix + 1 < fExpected.length() -
             fContextLength ? ELLIPSIS : "");
   }
 
   private boolean areStringsEqual() {
     return fExpected.equals(fActual);
   }
 }
 
 /////////////////////////////
 
 package junit.framework;
 
 public class ComparisonCompactor {
   private int ctxt;
   private String s1;
   private String s2;
   private int pfx;
   private int sfx;
 
   public ComparisonCompactor(int ctxt, String s1, String s2) {
     this.ctxt = ctxt;
     this.s1 = s1;
     this.s2 = s2;
   }
 
   public String compact(String msg) {
     if (s1 == null || s2 == null || s1.equals(s2))
       return Assert.format(msg, s1, s2);
 
     pfx = 0;
     for (; pfx < Math.min(s1.length(), s2.length()); pfx++) {
       if (s1.charAt(pfx) != s2.charAt(pfx))
         break;
     }
     int sfx1 = s1.length() - 1;
     int sfx2 = s2.length() - 1;
     for (; sfx2 >= pfx && sfx1 >= pfx; sfx2--, sfx1--) {
       if (s1.charAt(sfx1) != s2.charAt(sfx2))
         break;
     }
     sfx = s1.length() - sfx1;
     String cmp1 = compactString(s1);
     String cmp2 = compactString(s2);
     return Assert.format(msg, cmp1, cmp2);
   }
 
   private String compactString(String s) {
     String result =
       "[" + s.substring(pfx, s.length() - sfx + 1) + "]";
     if (pfx > 0)
       result = (pfx > ctxt ? "..." : "") +
         s1.substring(Math.max(0, pfx - ctxt), pfx) + result;
     if (sfx > 0) {
       int end = Math.min(s1.length() - sfx + 1 + ctxt, s1.length());
       result = result + (s1.substring(s1.length() - sfx + 1, end) +
         (s1.length() - sfx + 1 < s1.length() - ctxt ? "..." : ""));
     }
     return result;
   }
 }
 
 ///////////////////////////////
 
 public class ComparisonCompactor {
    ...
      private int suffixLength;
    ...
      private void findCommonPrefixAndSuffix() {
        findCommonPrefix();
        suffixLength = 0;
        for (; !suffixOverlapsPrefix(suffixLength); suffixLength++) {
          if (charFromEnd(expected, suffixLength) !=
              charFromEnd(actual, suffixLength))
            break;
        }
      }
    
      private char charFromEnd(String s, int i) {
        return s.charAt(s.length() - i - 1);
      }
    
      private boolean suffixOverlapsPrefix(int suffixLength) {
        return actual.length() - suffixLength <= prefixLength ||
        expected.length() - suffixLength <= prefixLength;
      }
    
    ...
      private String compactString(String source) {
        String result =
          DELTA_START +
          source.substring(prefixLength, source.length() - suffixLength) +
          DELTA_END;
        if (prefixLength > 0)
          result = computeCommonPrefix() + result;
        if (suffixLength > 0)
          result = result + computeCommonSuffix();
        return result;
      }
    
    ...
      private String computeCommonSuffix() {
        int end = Math.min(expected.length() - suffixLength +
        contextLength, expected.length()
        );
        return
          expected.substring(expected.length() - suffixLength, end) +
          (expected.length() - suffixLength <
            expected.length() - contextLength ?
            ELLIPSIS : "");
      }
    
 //////////////////////
 
 package junit.framework;
 
 public class ComparisonCompactor {
 
   private static final String ELLIPSIS = "...";
   private static final String DELTA_END = "]";
   private static final String DELTA_START = "[";
 
   private int contextLength;
   private String expected;
   private String actual;
   private int prefixLength;
   private int suffixLength;
 
   public ComparisonCompactor(
     int contextLength, String expected, String actual
   ) {
     this.contextLength = contextLength;
     this.expected = expected;
     this.actual = actual;
   }
 
   public String formatCompactedComparison(String message) {
     String compactExpected = expected;
     String compactActual = actual;
     if (shouldBeCompacted()) {
       findCommonPrefixAndSuffix();
       compactExpected = compact(expected);
       compactActual = compact(actual);
     }
     return Assert.format(message, compactExpected, compactActual);
   }
 
   private boolean shouldBeCompacted() {
     return !shouldNotBeCompacted();
   }
 
   private boolean shouldNotBeCompacted() {
     return expected == null ||
            actual == null ||
            expected.equals(actual);
   }
 
   private void findCommonPrefixAndSuffix() {
     findCommonPrefix();
     suffixLength = 0;
     for (; !suffixOverlapsPrefix(); suffixLength++) {
       if (charFromEnd(expected, suffixLength) !=
           charFromEnd(actual, suffixLength)
       )
         break;
     }
   }
 
   private char charFromEnd(String s, int i) {
     return s.charAt(s.length() - i - 1);
   }
 
   private boolean suffixOverlapsPrefix() {
     return actual.length() - suffixLength <= prefixLength ||
       expected.length() - suffixLength <= prefixLength;
   }
 
   private void findCommonPrefix() {
     prefixLength = 0;
     int end = Math.min(expected.length(), actual.length());
     for (; prefixLength < end; prefixLength++)
       if (expected.charAt(prefixLength) != actual.charAt(prefixLength))
         break;
   }
 
   private String compact(String s) {
     return new StringBuilder()
       .append(startingEllipsis())
       .append(startingContext())
       .append(DELTA_START)
       .append(delta(s))
       .append(DELTA_END)
       .append(endingContext())
       .append(endingEllipsis())
       .toString();
   }
 
   private String startingEllipsis() {
     return prefixLength > contextLength ? ELLIPSIS : "";
   }
 
   private String startingContext() {
     int contextStart = Math.max(0, prefixLength - contextLength);
     int contextEnd = prefixLength;
     return expected.substring(contextStart, contextEnd);
   }
 
   private String delta(String s) {
     int deltaStart = prefixLength;
     int deltaEnd = s.length() - suffixLength;
     return s.substring(deltaStart, deltaEnd);
   }
 
   private String endingContext() {
     int contextStart = expected.length() - suffixLength;
     int contextEnd =
       Math.min(contextStart + contextLength, expected.length());
     return expected.substring(contextStart, contextEnd);
   }
 
   private String endingEllipsis() {
     return (suffixLength > contextLength ? ELLIPSIS : "");
   }
 }
 
 ////////////////////////////////
 
 public class HourlyReporter {
    private HourlyReportFormatter formatter;
    private List<LineItem> page;
    private final int PAGE_SIZE = 55;
  
    public HourlyReporter(HourlyReportFormatter formatter) {
      this.formatter = formatter;
      page = new ArrayList<LineItem>();
    }
  
    public void generateReport(List<HourlyEmployee> employees) {
      for (HourlyEmployee e : employees) {
        addLineItemToPage(e);
        if (page.size() == PAGE_SIZE)
          printAndClearItemList();
      }
      if (page.size() > 0)
        printAndClearItemList();
    }
  
    private void printAndClearItemList() {
      formatter.format(page);
      page.clear();
    }
  
    private void addLineItemToPage(HourlyEmployee e) {
      LineItem item = new LineItem();
      item.name = e.getName();
      item.hours = e.getTenthsWorked() / 10;
      item.tenths = e.getTenthsWorked() % 10;
      page.add(item);
    }
  
    public class LineItem {
      public String name;
      public int hours;
      public int tenths;
    }
  }
 
 /////////////////////////////////
 
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 
 public class ExecutorClientScheduler implements ClientScheduler {
   Executor executor;
 
   public ExecutorClientScheduler(int availableThreads) {
     executor = Executors.newFixedThreadPool(availableThreads);
   }
 
   public void schedule(final ClientRequestProcessor requestProcessor) {
     Runnable runnable = new Runnable() {
       public void run() {
         requestProcessor.process();
         }
     };
     executor.execute(runnable);
   }
 }
 
 ///////////////////////////////////
 
 01: package example;
 02:
 03: import static org.junit.Assert.fail;
 04:
 05: import org.junit.Test;
 06:
 07: public class ClassWithThreadingProblemTest {
 08:      @Test
 09:      public void twoThreadsShouldFailEventually() throws Exception {
 10:          final ClassWithThreadingProblem classWithThreadingProblem
                  = new ClassWithThreadingProblem();
 11:
 12:         Runnable runnable = new Runnable() {
 13:             public void run() {
 14:                 classWithThreadingProblem.takeNextId();
 15:             }
 16:         };
 17:
 18:         for (int i = 0; i < 50000; ++i) {
 19:             int startingId = classWithThreadingProblem.lastId;
 20:             int expectedResult = 2 + startingId;
 21:
 22:             Thread t1 = new Thread(runnable);
 23:             Thread t2 = new Thread(runnable);
 24:             t1.start();
 25:             t2.start();
 26:             t1.join();
 27:             t2.join();
 28:
 29:             int endingId = classWithThreadingProblem.lastId;
 30:
 31:             if (endingId != expectedResult)
 32:                 return;
 33:         }
 34:
 35:         fail("Powinien pokaza� problem z w�tkami, ale si� to nie uda�o.");
 36:     }
 37: }
 
 ///////////////////////////////////////
 
 package com.objectmentor.clientserver.nonthreaded;
 
 import java.io.IOException;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketException;
 
 import common.MessageUtils;
 
 public class Server implements Runnable {
   ServerSocket serverSocket;
   volatile boolean keepProcessing = true;
 
   public Server(int port, int millisecondsTimeout) throws IOException {
   serverSocket = new ServerSocket(port);
   serverSocket.setSoTimeout(millisecondsTimeout);
   }
 
   public void run() {
     System.out.printf("Serwer uruchamia si�\n");
 
     while (keepProcessing) {
       try {
         System.out.printf("przyjmowanie klienta\n");
         Socket socket = serverSocket.accept();
         System.out.printf("klient przyjety\n");
         process(socket);
       } catch (Exception e) {
         handle(e);
       }
     }
   }
 
   private void handle(Exception e) {
     if (!(e instanceof SocketException)) {
       e.printStackTrace();
     }
   }
 
   public void stopProcessing() {
     keepProcessing = false;
     closeIgnoringException(serverSocket);
   }
 
   void process(Socket socket) {
     if (socket == null)
       return;
 
     try {
       System.out.printf("Serwer: pobieranie komunikatu\n");
       String message = MessageUtils.getMessage(socket);
       System.out.printf("Serwer: komunikat pobrany: %s\n", message);
       Thread.sleep(1000);
       System.out.printf("Serwer: wysy�anie odpowiedzi: %s\n", message);
       MessageUtils.sendMessage(socket, "Przetworzone: " + message);
       System.out.printf("Serwer: wys�ane\n");
       closeIgnoringException(socket);
     } catch (Exception e) {
       e.printStackTrace();
     }
   }
 
   private void closeIgnoringException(Socket socket) {
   if (socket != null)
     try {
       socket.close();
     } catch (IOException ignore) {
     }
   }
 
   private void closeIgnoringException(ServerSocket serverSocket) {
     if (serverSocket != null)
       try {
         serverSocket.close();
       } catch (IOException ignore) {
       }
   }
 }
 
 ////////////////////////////////////////
 
 package com.objectmentor.clientserver.nonthreaded;
 
 import java.io.IOException;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketException;
 
 import common.MessageUtils;
 
 public class Server implements Runnable {
   ServerSocket serverSocket;
   volatile boolean keepProcessing = true;
 
   public Server(int port, int millisecondsTimeout) throws IOException {
     serverSocket = new ServerSocket(port);
     serverSocket.setSoTimeout(millisecondsTimeout);
   }
 
   public void run() {
     System.out.printf("Serwer uruchamia si�\n");
     while (keepProcessing) {
       try {
         System.out.printf("przyjmowanie klienta\n");
         Socket socket = serverSocket.accept();
         System.out.printf("klient przyjety\n");
         process(socket);
       } catch (Exception e) {
         handle(e);
       }
     }
   }
 
   private void handle(Exception e) {
     if (!(e instanceof SocketException)) {
       e.printStackTrace();
     }
   }
 
   public void stopProcessing() {
     keepProcessing = false;
     closeIgnoringException(serverSocket);
   }
 
   void process(Socket socket) {
     if (socket == null)
       return;
 
     try {
       System.out.printf("Serwer: pobieranie komunikatu\n");
       String message = MessageUtils.getMessage(socket);
       System.out.printf("Serwer: komunikat pobrany: %s\n", message);
       Thread.sleep(1000);
       System.out.printf("Serwer: wysy�anie odpowiedzi: %s\n", message);
       MessageUtils.sendMessage(socket, "Przetworzone: " + message);
       System.out.printf("Serwer: wys�ane\n");
       closeIgnoringException(socket);
     } catch (Exception e) {
       e.printStackTrace();
     }
   }
 
   private void closeIgnoringException(Socket socket) {
     if (socket != null)
       try {
         socket.close();
       } catch (IOException ignore) {
       }
   }
 
   private void closeIgnoringException(ServerSocket serverSocket) {
     if (serverSocket != null)
       try {
         serverSocket.close();
       } catch (IOException ignore) {
       }
   }
 }
 
 /////////////////////////////////////////////
 
 package common;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.OutputStream;
 import java.net.Socket;
 
 public class MessageUtils {
   public static void sendMessage(Socket socket, String message)
            throws IOException {
     OutputStream stream = socket.getOutputStream();
     ObjectOutputStream oos = new ObjectOutputStream(stream);
     oos.writeUTF(message);
     oos.flush();
   }
 
   public static String getMessage(Socket socket) throws IOException {
     InputStream stream = socket.getInputStream();
     ObjectInputStream ois = new ObjectInputStream(stream);
     return ois.readUTF();
   }
 }
 
 //////////////////////////////////////////////
 
 /* ========================================================================
  * JCommon : a free general purpose class library for the Java(tm) platform
  * ========================================================================
  *
  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
  * 
  * Project Info:  http://www.jfree.org/jcommon/index.html
  *
  * This library is free software; you can redistribute it and/or modify it 
  * under the terms of the GNU Lesser General Public License as published by 
  * the Free Software Foundation; either version 2.1 of the License, or 
  * (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful, but 
  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
  * License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 
  * USA.  
  *
  * [Java is a trademark or registered trademark of Sun Microsystems, Inc. 
  * in the United States and other countries.]
  *
  * ---------------
  * SerialDate.java
  * ---------------
  * (C) Copyright 2001-2005, by Object Refinery Limited.
  *
  * Original Author:  David Gilbert (for Object Refinery Limited);
  * Contributor(s):   -;
  *
  * $Id: SerialDate.java,v 1.7 2005/11/03 09:25:17 mungady Exp $
  *
  * Changes (from 11-Oct-2001)
  * --------------------------
  * 11-Oct-2001 : Re-organised the class and moved it to new package 
  *               com.jrefinery.date (DG);
  * 05-Nov-2001 : Added a getDescription() method, and eliminated NotableDate 
  *               class (DG);
  * 12-Nov-2001 : IBD requires setDescription() method, now that NotableDate 
  *               class is gone (DG);  Changed getPreviousDayOfWeek(), 
  *               getFollowingDayOfWeek() and getNearestDayOfWeek() to correct 
  *               bugs (DG);
  * 05-Dec-2001 : Fixed bug in SpreadsheetDate class (DG);
  * 29-May-2002 : Moved the month constants into a separate interface 
  *               (MonthConstants) (DG);
  * 27-Aug-2002 : Fixed bug in addMonths() method, thanks to N???levka Petr (DG);
  * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG);
  * 13-Mar-2003 : Implemented Serializable (DG);
  * 29-May-2003 : Fixed bug in addMonths method (DG);
  * 04-Sep-2003 : Implemented Comparable.  Updated the isInRange javadocs (DG);
  * 05-Jan-2005 : Fixed bug in addYears() method (1096282) (DG);
  * 
  */
 
 package org.jfree.date;
 
 import java.io.Serializable;
 import java.text.DateFormatSymbols;
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.GregorianCalendar;
 
 /**
  *  An abstract class that defines our requirements for manipulating dates,
  *  without tying down a particular implementation.
  *  <P>
  *  Requirement 1 : match at least what Excel does for dates;
  *  Requirement 2 : class is immutable;
  *  <P>
  *  Why not just use java.util.Date?  We will, when it makes sense.  At times,
  *  java.util.Date can be *too* precise - it represents an instant in time,
  *  accurate to 1/1000th of a second (with the date itself depending on the
  *  time-zone).  Sometimes we just want to represent a particular day (e.g. 21
  *  January 2015) without concerning ourselves about the time of day, or the
  *  time-zone, or anything else.  That's what we've defined SerialDate for.
  *  <P>
  *  You can call getInstance() to get a concrete subclass of SerialDate,
  *  without worrying about the exact implementation.
  *
  * @author David Gilbert
  */
 public abstract class SerialDate implements Comparable, 
                                             Serializable, 
                                             MonthConstants {
 
     /** For serialization. */
     private static final long serialVersionUID = -293716040467423637L;
     
     /** Date format symbols. */
     public static final DateFormatSymbols
         DATE_FORMAT_SYMBOLS = new SimpleDateFormat().getDateFormatSymbols();
 
     /** The serial number for 1 January 1900. */
     public static final int SERIAL_LOWER_BOUND = 2;
 
     /** The serial number for 31 December 9999. */
     public static final int SERIAL_UPPER_BOUND = 2958465;
 
     /** The lowest year value supported by this date format. */
     public static final int MINIMUM_YEAR_SUPPORTED = 1900;
 
     /** The highest year value supported by this date format. */
     public static final int MAXIMUM_YEAR_SUPPORTED = 9999;
 
     /** Useful constant for Monday. Equivalent to java.util.Calendar.MONDAY. */
     public static final int MONDAY = Calendar.MONDAY;
 
     /** 
      * Useful constant for Tuesday. Equivalent to java.util.Calendar.TUESDAY. 
      */
     public static final int TUESDAY = Calendar.TUESDAY;
 
     /** 
      * Useful constant for Wednesday. Equivalent to 
      * java.util.Calendar.WEDNESDAY. 
      */
     public static final int WEDNESDAY = Calendar.WEDNESDAY;
 
     /** 
      * Useful constant for Thrusday. Equivalent to java.util.Calendar.THURSDAY. 
      */
     public static final int THURSDAY = Calendar.THURSDAY;
 
     /** Useful constant for Friday. Equivalent to java.util.Calendar.FRIDAY. */
     public static final int FRIDAY = Calendar.FRIDAY;
 
     /** 
      * Useful constant for Saturday. Equivalent to java.util.Calendar.SATURDAY.
      */
     public static final int SATURDAY = Calendar.SATURDAY;
 
     /** Useful constant for Sunday. Equivalent to java.util.Calendar.SUNDAY. */
     public static final int SUNDAY = Calendar.SUNDAY;
 
     /** The number of days in each month in non leap years. */
     static final int[] LAST_DAY_OF_MONTH =
         {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
 
     /** The number of days in a (non-leap) year up to the end of each month. */
     static final int[] AGGREGATE_DAYS_TO_END_OF_MONTH =
         {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
 
     /** The number of days in a year up to the end of the preceding month. */
     static final int[] AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =
         {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
 
     /** The number of days in a leap year up to the end of each month. */
     static final int[] LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH =
         {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
 
     /** 
      * The number of days in a leap year up to the end of the preceding month. 
      */
     static final int[] 
         LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =
             {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
 
     /** A useful constant for referring to the first week in a month. */
     public static final int FIRST_WEEK_IN_MONTH = 1;
 
     /** A useful constant for referring to the second week in a month. */
     public static final int SECOND_WEEK_IN_MONTH = 2;
 
     /** A useful constant for referring to the third week in a month. */
     public static final int THIRD_WEEK_IN_MONTH = 3;
 
     /** A useful constant for referring to the fourth week in a month. */
     public static final int FOURTH_WEEK_IN_MONTH = 4;
 
     /** A useful constant for referring to the last week in a month. */
     public static final int LAST_WEEK_IN_MONTH = 0;
 
     /** Useful range constant. */
     public static final int INCLUDE_NONE = 0;
 
     /** Useful range constant. */
     public static final int INCLUDE_FIRST = 1;
 
     /** Useful range constant. */
     public static final int INCLUDE_SECOND = 2;
 
     /** Useful range constant. */
     public static final int INCLUDE_BOTH = 3;
 
     /** 
      * Useful constant for specifying a day of the week relative to a fixed 
      * date. 
      */
     public static final int PRECEDING = -1;
 
     /** 
      * Useful constant for specifying a day of the week relative to a fixed 
      * date. 
      */
     public static final int NEAREST = 0;
 
     /** 
      * Useful constant for specifying a day of the week relative to a fixed 
      * date. 
      */
     public static final int FOLLOWING = 1;
 
     /** A description for the date. */
     private String description;
 
     /**
      * Default constructor.
      */
     protected SerialDate() {
     }
 
     /**
      * Returns <code>true</code> if the supplied integer code represents a 
      * valid day-of-the-week, and <code>false</code> otherwise.
      *
      * @param code  the code being checked for validity.
      *
      * @return <code>true</code> if the supplied integer code represents a 
      *         valid day-of-the-week, and <code>false</code> otherwise.
      */
     public static boolean isValidWeekdayCode(final int code) {
 
         switch(code) {
             case SUNDAY: 
             case MONDAY: 
             case TUESDAY: 
             case WEDNESDAY: 
             case THURSDAY: 
             case FRIDAY: 
             case SATURDAY: 
                 return true;
             default: 
                 return false;
         }
 
     }
 
     /**
      * Converts the supplied string to a day of the week.
      *
      * @param s  a string representing the day of the week.
      *
      * @return <code>-1</code> if the string is not convertable, the day of 
      *         the week otherwise.
      */
     public static int stringToWeekdayCode(String s) {
 
         final String[] shortWeekdayNames 
             = DATE_FORMAT_SYMBOLS.getShortWeekdays();
         final String[] weekDayNames = DATE_FORMAT_SYMBOLS.getWeekdays();
 
         int result = -1;
         s = s.trim();
         for (int i = 0; i < weekDayNames.length; i++) {
             if (s.equals(shortWeekdayNames[i])) {
                 result = i;
                 break;
             }
             if (s.equals(weekDayNames[i])) {
                 result = i;
                 break;
             }
         }
         return result;
 
     }
 
     /**
      * Returns a string representing the supplied day-of-the-week.
      * <P>
      * Need to find a better approach.
      *
      * @param weekday  the day of the week.
      *
      * @return a string representing the supplied day-of-the-week.
      */
     public static String weekdayCodeToString(final int weekday) {
 
         final String[] weekdays = DATE_FORMAT_SYMBOLS.getWeekdays();
         return weekdays[weekday];
 
     }
 
     /**
      * Returns an array of month names.
      *
      * @return an array of month names.
      */
     public static String[] getMonths() {
 
         return getMonths(false);
 
     }
 
     /**
      * Returns an array of month names.
      *
      * @param shortened  a flag indicating that shortened month names should 
      *                   be returned.
      *
      * @return an array of month names.
      */
     public static String[] getMonths(final boolean shortened) {
 
         if (shortened) {
             return DATE_FORMAT_SYMBOLS.getShortMonths();
         }
         else {
             return DATE_FORMAT_SYMBOLS.getMonths();
         }
 
     }
 
     /**
      * Returns true if the supplied integer code represents a valid month.
      *
      * @param code  the code being checked for validity.
      *
      * @return <code>true</code> if the supplied integer code represents a 
      *         valid month.
      */
     public static boolean isValidMonthCode(final int code) {
 
         switch(code) {
             case JANUARY: 
             case FEBRUARY: 
             case MARCH: 
             case APRIL: 
             case MAY: 
             case JUNE: 
             case JULY: 
             case AUGUST: 
             case SEPTEMBER: 
             case OCTOBER: 
             case NOVEMBER: 
             case DECEMBER: 
                 return true;
             default: 
                 return false;
         }
 
     }
 
     /**
      * Returns the quarter for the specified month.
      *
      * @param code  the month code (1-12).
      *
      * @return the quarter that the month belongs to.
      * @throws java.lang.IllegalArgumentException
      */
     public static int monthCodeToQuarter(final int code) {
 
         switch(code) {
             case JANUARY: 
             case FEBRUARY: 
             case MARCH: return 1;
             case APRIL: 
             case MAY: 
             case JUNE: return 2;
             case JULY: 
             case AUGUST: 
             case SEPTEMBER: return 3;
             case OCTOBER: 
             case NOVEMBER: 
             case DECEMBER: return 4;
             default: throw new IllegalArgumentException(
                 "SerialDate.monthCodeToQuarter: invalid month code.");
         }
 
     }
 
     /**
      * Returns a string representing the supplied month.
      * <P>
      * The string returned is the long form of the month name taken from the 
      * default locale.
      *
      * @param month  the month.
      *
      * @return a string representing the supplied month.
      */
     public static String monthCodeToString(final int month) {
 
         return monthCodeToString(month, false);
 
     }
 
     /**
      * Returns a string representing the supplied month.
      * <P>
      * The string returned is the long or short form of the month name taken 
      * from the default locale.
      *
      * @param month  the month.
      * @param shortened  if <code>true</code> return the abbreviation of the 
      *                   month.
      *
      * @return a string representing the supplied month.
      * @throws java.lang.IllegalArgumentException
      */
     public static String monthCodeToString(final int month, 
                                            final boolean shortened) {
 
         // check arguments...
         if (!isValidMonthCode(month)) {
             throw new IllegalArgumentException(
                 "SerialDate.monthCodeToString: month outside valid range.");
         }
 
         final String[] months;
 
         if (shortened) {
             months = DATE_FORMAT_SYMBOLS.getShortMonths();
         }
         else {
             months = DATE_FORMAT_SYMBOLS.getMonths();
         }
 
         return months[month - 1];
 
     }
 
     /**
      * Converts a string to a month code.
      * <P>
      * This method will return one of the constants JANUARY, FEBRUARY, ..., 
      * DECEMBER that corresponds to the string.  If the string is not 
      * recognised, this method returns -1.
      *
      * @param s  the string to parse.
      *
      * @return <code>-1</code> if the string is not parseable, the month of the
      *         year otherwise.
      */
     public static int stringToMonthCode(String s) {
 
         final String[] shortMonthNames = DATE_FORMAT_SYMBOLS.getShortMonths();
         final String[] monthNames = DATE_FORMAT_SYMBOLS.getMonths();
 
         int result = -1;
         s = s.trim();
 
         // first try parsing the string as an integer (1-12)...
         try {
             result = Integer.parseInt(s);
         }
         catch (NumberFormatException e) {
             // suppress
         }
 
         // now search through the month names...
         if ((result < 1) || (result > 12)) {
             for (int i = 0; i < monthNames.length; i++) {
                 if (s.equals(shortMonthNames[i])) {
                     result = i + 1;
                     break;
                 }
                 if (s.equals(monthNames[i])) {
                     result = i + 1;
                     break;
                 }
             }
         }
 
         return result;
 
     }
 
     /**
      * Returns true if the supplied integer code represents a valid 
      * week-in-the-month, and false otherwise.
      *
      * @param code  the code being checked for validity.
      * @return <code>true</code> if the supplied integer code represents a 
      *         valid week-in-the-month.
      */
     public static boolean isValidWeekInMonthCode(final int code) {
 
         switch(code) {
             case FIRST_WEEK_IN_MONTH: 
             case SECOND_WEEK_IN_MONTH: 
             case THIRD_WEEK_IN_MONTH: 
             case FOURTH_WEEK_IN_MONTH: 
             case LAST_WEEK_IN_MONTH: return true;
             default: return false;
         }
 
     }
 
     /**
      * Determines whether or not the specified year is a leap year.
      *
      * @param yyyy  the year (in the range 1900 to 9999).
      *
      * @return <code>true</code> if the specified year is a leap year.
      */
     public static boolean isLeapYear(final int yyyy) {
 
         if ((yyyy % 4) != 0) {
             return false;
         }
         else if ((yyyy % 400) == 0) {
             return true;
         }
         else if ((yyyy % 100) == 0) {
             return false;
         }
         else {
             return true;
         }
 
     }
 
     /**
      * Returns the number of leap years from 1900 to the specified year 
      * INCLUSIVE.
      * <P>
      * Note that 1900 is not a leap year.
      *
      * @param yyyy  the year (in the range 1900 to 9999).
      *
      * @return the number of leap years from 1900 to the specified year.
      */
     public static int leapYearCount(final int yyyy) {
 
         final int leap4 = (yyyy - 1896) / 4;
         final int leap100 = (yyyy - 1800) / 100;
         final int leap400 = (yyyy - 1600) / 400;
         return leap4 - leap100 + leap400;
 
     }
 
     /**
      * Returns the number of the last day of the month, taking into account 
      * leap years.
      *
      * @param month  the month.
      * @param yyyy  the year (in the range 1900 to 9999).
      *
      * @return the number of the last day of the month.
      */
     public static int lastDayOfMonth(final int month, final int yyyy) {
 
         final int result = LAST_DAY_OF_MONTH[month];
         if (month != FEBRUARY) {
             return result;
         }
         else if (isLeapYear(yyyy)) {
             return result + 1;
         }
         else {
             return result;
         }
 
     }
 
     /**
      * Creates a new date by adding the specified number of days to the base 
      * date.
      *
      * @param days  the number of days to add (can be negative).
      * @param base  the base date.
      *
      * @return a new date.
      */
     public static SerialDate addDays(final int days, final SerialDate base) {
 
         final int serialDayNumber = base.toSerial() + days;
         return SerialDate.createInstance(serialDayNumber);
 
     }
 
     /**
      * Creates a new date by adding the specified number of months to the base 
      * date.
      * <P>
      * If the base date is close to the end of the month, the day on the result
      * may be adjusted slightly:  31 May + 1 month = 30 June.
      *
      * @param months  the number of months to add (can be negative).
      * @param base  the base date.
      *
      * @return a new date.
      */
     public static SerialDate addMonths(final int months, 
                                        final SerialDate base) {
 
         final int yy = (12 * base.getYYYY() + base.getMonth() + months - 1) 
                        / 12;
         final int mm = (12 * base.getYYYY() + base.getMonth() + months - 1) 
                        % 12 + 1;
         final int dd = Math.min(
             base.getDayOfMonth(), SerialDate.lastDayOfMonth(mm, yy)
         );
         return SerialDate.createInstance(dd, mm, yy);
 
     }
 
     /**
      * Creates a new date by adding the specified number of years to the base 
      * date.
      *
      * @param years  the number of years to add (can be negative).
      * @param base  the base date.
      *
      * @return A new date.
      */
     public static SerialDate addYears(final int years, final SerialDate base) {
 
         final int baseY = base.getYYYY();
         final int baseM = base.getMonth();
         final int baseD = base.getDayOfMonth();
 
         final int targetY = baseY + years;
         final int targetD = Math.min(
             baseD, SerialDate.lastDayOfMonth(baseM, targetY)
         );
 
         return SerialDate.createInstance(targetD, baseM, targetY);
 
     }
 
     /**
      * Returns the latest date that falls on the specified day-of-the-week and 
      * is BEFORE the base date.
      *
      * @param targetWeekday  a code for the target day-of-the-week.
      * @param base  the base date.
      *
      * @return the latest date that falls on the specified day-of-the-week and 
      *         is BEFORE the base date.
      */
     public static SerialDate getPreviousDayOfWeek(final int targetWeekday, 
                                                   final SerialDate base) {
 
         // check arguments...
         if (!SerialDate.isValidWeekdayCode(targetWeekday)) {
             throw new IllegalArgumentException(
                 "Invalid day-of-the-week code."
             );
         }
 
         // find the date...
         final int adjust;
         final int baseDOW = base.getDayOfWeek();
         if (baseDOW > targetWeekday) {
             adjust = Math.min(0, targetWeekday - baseDOW);
         }
         else {
             adjust = -7 + Math.max(0, targetWeekday - baseDOW);
         }
 
         return SerialDate.addDays(adjust, base);
 
     }
 
     /**
      * Returns the earliest date that falls on the specified day-of-the-week
      * and is AFTER the base date.
      *
      * @param targetWeekday  a code for the target day-of-the-week.
      * @param base  the base date.
      *
      * @return the earliest date that falls on the specified day-of-the-week 
      *         and is AFTER the base date.
      */
     public static SerialDate getFollowingDayOfWeek(final int targetWeekday, 
                                                    final SerialDate base) {
 
         // check arguments...
         if (!SerialDate.isValidWeekdayCode(targetWeekday)) {
             throw new IllegalArgumentException(
                 "Invalid day-of-the-week code."
             );
         }
 
         // find the date...
         final int adjust;
         final int baseDOW = base.getDayOfWeek();
         if (baseDOW > targetWeekday) {
             adjust = 7 + Math.min(0, targetWeekday - baseDOW);
         }
         else {
             adjust = Math.max(0, targetWeekday - baseDOW);
         }
 
         return SerialDate.addDays(adjust, base);
     }
 
     /**
      * Returns the date that falls on the specified day-of-the-week and is
      * CLOSEST to the base date.
      *
      * @param targetDOW  a code for the target day-of-the-week.
      * @param base  the base date.
      *
      * @return the date that falls on the specified day-of-the-week and is 
      *         CLOSEST to the base date.
      */
     public static SerialDate getNearestDayOfWeek(final int targetDOW,  
                                                  final SerialDate base) {
 
         // check arguments...
         if (!SerialDate.isValidWeekdayCode(targetDOW)) {
             throw new IllegalArgumentException(
                 "Invalid day-of-the-week code."
             );
         }
 
         // find the date...
         final int baseDOW = base.getDayOfWeek();
         int adjust = -Math.abs(targetDOW - baseDOW);
         if (adjust >= 4) {
             adjust = 7 - adjust;
         }
         if (adjust <= -4) {
             adjust = 7 + adjust;
         }
         return SerialDate.addDays(adjust, base);
 
     }
 
     /**
      * Rolls the date forward to the last day of the month.
      *
      * @param base  the base date.
      *
      * @return a new serial date.
      */
     public SerialDate getEndOfCurrentMonth(final SerialDate base) {
         final int last = SerialDate.lastDayOfMonth(
             base.getMonth(), base.getYYYY()
         );
         return SerialDate.createInstance(last, base.getMonth(), base.getYYYY());
     }
 
     /**
      * Returns a string corresponding to the week-in-the-month code.
      * <P>
      * Need to find a better approach.
      *
      * @param count  an integer code representing the week-in-the-month.
      *
      * @return a string corresponding to the week-in-the-month code.
      */
     public static String weekInMonthToString(final int count) {
 
         switch (count) {
             case SerialDate.FIRST_WEEK_IN_MONTH : return "First";
             case SerialDate.SECOND_WEEK_IN_MONTH : return "Second";
             case SerialDate.THIRD_WEEK_IN_MONTH : return "Third";
             case SerialDate.FOURTH_WEEK_IN_MONTH : return "Fourth";
             case SerialDate.LAST_WEEK_IN_MONTH : return "Last";
             default :
                 return "SerialDate.weekInMonthToString(): invalid code.";
         }
 
     }
 
     /**
      * Returns a string representing the supplied 'relative'.
      * <P>
      * Need to find a better approach.
      *
      * @param relative  a constant representing the 'relative'.
      *
      * @return a string representing the supplied 'relative'.
      */
     public static String relativeToString(final int relative) {
 
         switch (relative) {
             case SerialDate.PRECEDING : return "Preceding";
             case SerialDate.NEAREST : return "Nearest";
             case SerialDate.FOLLOWING : return "Following";
             default : return "ERROR : Relative To String";
         }
 
     }
 
     /**
      * Factory method that returns an instance of some concrete subclass of 
      * {@link SerialDate}.
      *
      * @param day  the day (1-31).
      * @param month  the month (1-12).
      * @param yyyy  the year (in the range 1900 to 9999).
      *
      * @return An instance of {@link SerialDate}.
      */
     public static SerialDate createInstance(final int day, final int month, 
                                             final int yyyy) {
         return new SpreadsheetDate(day, month, yyyy);
     }
 
     /**
      * Factory method that returns an instance of some concrete subclass of 
      * {@link SerialDate}.
      *
      * @param serial  the serial number for the day (1 January 1900 = 2).
      *
      * @return a instance of SerialDate.
      */
     public static SerialDate createInstance(final int serial) {
         return new SpreadsheetDate(serial);
     }
 
     /**
      * Factory method that returns an instance of a subclass of SerialDate.
      *
      * @param date  A Java date object.
      *
      * @return a instance of SerialDate.
      */
     public static SerialDate createInstance(final java.util.Date date) {
 
         final GregorianCalendar calendar = new GregorianCalendar();
         calendar.setTime(date);
         return new SpreadsheetDate(calendar.get(Calendar.DATE),
                                    calendar.get(Calendar.MONTH) + 1,
                                    calendar.get(Calendar.YEAR));
 
     }
 
     /**
      * Returns the serial number for the date, where 1 January 1900 = 2 (this
      * corresponds, almost, to the numbering system used in Microsoft Excel for
      * Windows and Lotus 1-2-3).
      *
      * @return the serial number for the date.
      */
     public abstract int toSerial();
 
     /**
      * Returns a java.util.Date.  Since java.util.Date has more precision than
      * SerialDate, we need to define a convention for the 'time of day'.
      *
      * @return this as <code>java.util.Date</code>.
      */
     public abstract java.util.Date toDate();
 
     /**
      * Returns a description of the date.
      *
      * @return a description of the date.
      */
     public String getDescription() {
         return this.description;
     }
 
     /**
      * Sets the description for the date.
      *
      * @param description  the new description for the date.
      */
     public void setDescription(final String description) {
         this.description = description;
     }
 
     /**
      * Converts the date to a string.
      *
      * @return  a string representation of the date.
      */
     public String toString() {
         return getDayOfMonth() + "-" + SerialDate.monthCodeToString(getMonth())
                                + "-" + getYYYY();
     }
 
     /**
      * Returns the year (assume a valid range of 1900 to 9999).
      *
      * @return the year.
      */
     public abstract int getYYYY();
 
     /**
      * Returns the month (January = 1, February = 2, March = 3).
      *
      * @return the month of the year.
      */
     public abstract int getMonth();
 
     /**
      * Returns the day of the month.
      *
      * @return the day of the month.
      */
     public abstract int getDayOfMonth();
 
     /**
      * Returns the day of the week.
      *
      * @return the day of the week.
      */
     public abstract int getDayOfWeek();
 
     /**
      * Returns the difference (in days) between this date and the specified 
      * 'other' date.
      * <P>
      * The result is positive if this date is after the 'other' date and
      * negative if it is before the 'other' date.
      *
      * @param other  the date being compared to.
      *
      * @return the difference between this and the other date.
      */
     public abstract int compare(SerialDate other);
 
     /**
      * Returns true if this SerialDate represents the same date as the 
      * specified SerialDate.
      *
      * @param other  the date being compared to.
      *
      * @return <code>true</code> if this SerialDate represents the same date as 
      *         the specified SerialDate.
      */
     public abstract boolean isOn(SerialDate other);
 
     /**
      * Returns true if this SerialDate represents an earlier date compared to
      * the specified SerialDate.
      *
      * @param other  The date being compared to.
      *
      * @return <code>true</code> if this SerialDate represents an earlier date 
      *         compared to the specified SerialDate.
      */
     public abstract boolean isBefore(SerialDate other);
 
     /**
      * Returns true if this SerialDate represents the same date as the 
      * specified SerialDate.
      *
      * @param other  the date being compared to.
      *
      * @return <code>true<code> if this SerialDate represents the same date
      *         as the specified SerialDate.
      */
     public abstract boolean isOnOrBefore(SerialDate other);
 
     /**
      * Returns true if this SerialDate represents the same date as the 
      * specified SerialDate.
      *
      * @param other  the date being compared to.
      *
      * @return <code>true</code> if this SerialDate represents the same date
      *         as the specified SerialDate.
      */
     public abstract boolean isAfter(SerialDate other);
 
     /**
      * Returns true if this SerialDate represents the same date as the 
      * specified SerialDate.
      *
      * @param other  the date being compared to.
      *
      * @return <code>true</code> if this SerialDate represents the same date
      *         as the specified SerialDate.
      */
     public abstract boolean isOnOrAfter(SerialDate other);
 
     /**
      * Returns <code>true</code> if this {@link SerialDate} is within the
      * specified range (INCLUSIVE).  The date order of d1 and d2 is not 
      * important.
      *
      * @param d1  a boundary date for the range.
      * @param d2  the other boundary date for the range.
      *
      * @return A boolean.
      */
     public abstract boolean isInRange(SerialDate d1, SerialDate d2);
 
     /**
      * Returns <code>true</code> if this {@link SerialDate} is within the 
      * specified range (caller specifies whether or not the end-points are 
      * included).  The date order of d1 and d2 is not important.
      *
      * @param d1  a boundary date for the range.
      * @param d2  the other boundary date for the range.
      * @param include  a code that controls whether or not the start and end 
      *                 dates are included in the range.
      *
      * @return A boolean.
      */
     public abstract boolean isInRange(SerialDate d1, SerialDate d2, 
                                       int include);
 
     /**
      * Returns the latest date that falls on the specified day-of-the-week and
      * is BEFORE this date.
      *
      * @param targetDOW  a code for the target day-of-the-week.
      *
      * @return the latest date that falls on the specified day-of-the-week and
      *         is BEFORE this date.
      */
     public SerialDate getPreviousDayOfWeek(final int targetDOW) {
         return getPreviousDayOfWeek(targetDOW, this);
     }
 
     /**
      * Returns the earliest date that falls on the specified day-of-the-week
      * and is AFTER this date.
      *
      * @param targetDOW  a code for the target day-of-the-week.
      *
      * @return the earliest date that falls on the specified day-of-the-week
      *         and is AFTER this date.
      */
     public SerialDate getFollowingDayOfWeek(final int targetDOW) {
         return getFollowingDayOfWeek(targetDOW, this);
     }
 
     /**
      * Returns the nearest date that falls on the specified day-of-the-week.
      *
      * @param targetDOW  a code for the target day-of-the-week.
      *
      * @return the nearest date that falls on the specified day-of-the-week.
      */
     public SerialDate getNearestDayOfWeek(final int targetDOW) {
         return getNearestDayOfWeek(targetDOW, this);
     }
 
 }
 
 //////////////////////////////////////////////////////////
 
 /* ========================================================================
  * JCommon : a free general purpose class library for the Java(tm) platform
  * ========================================================================
  *
  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
  * 
  * Project Info:  http://www.jfree.org/jcommon/index.html
  *
  * This library is free software; you can redistribute it and/or modify it 
  * under the terms of the GNU Lesser General Public License as published by 
  * the Free Software Foundation; either version 2.1 of the License, or 
  * (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful, but 
  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
  * License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 
  * USA.  
  *
  * [Java is a trademark or registered trademark of Sun Microsystems, Inc. 
  * in the United States and other countries.]
  *
  * --------------------
  * SerialDateTests.java
  * --------------------
  * (C) Copyright 2001-2005, by Object Refinery Limited.
  *
  * Original Author:  David Gilbert (for Object Refinery Limited);
  * Contributor(s):   -;
  *
  * $Id: SerialDateTests.java,v 1.5 2005/10/18 13:15:28 mungady Exp $
  *
  * Changes
  * -------
  * 15-Nov-2001 : Version 1 (DG);
  * 25-Jun-2002 : Removed unnecessary import (DG);
  * 24-Oct-2002 : Fixed errors reported by Checkstyle (DG);
  * 13-Mar-2003 : Added serialization test (DG);
  * 05-Jan-2005 : Added test for bug report 1096282 (DG);
  *
  */
 
 package org.jfree.date.junit;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.ObjectInput;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutput;
 import java.io.ObjectOutputStream;
 
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
 import org.jfree.date.MonthConstants;
 import org.jfree.date.SerialDate;
 
 /**
  * Some JUnit tests for the {@link SerialDate} class.
  */
 public class SerialDateTests extends TestCase {
 
     /** Date representing November 9. */
     private SerialDate nov9Y2001;
 
     /**
      * Creates a new test case.
      *
      * @param name  the name.
      */
     public SerialDateTests(final String name) {
         super(name);
     }
 
     /**
      * Returns a test suite for the JUnit test runner.
      *
      * @return The test suite.
      */
     public static Test suite() {
         return new TestSuite(SerialDateTests.class);
     }
 
     /**
      * Problem set up.
      */
     protected void setUp() {
         this.nov9Y2001 = SerialDate.createInstance(9, MonthConstants.NOVEMBER, 2001);
     }
 
     /**
      * 9 Nov 2001 plus two months should be 9 Jan 2002.
      */
     public void testAddMonthsTo9Nov2001() {
         final SerialDate jan9Y2002 = SerialDate.addMonths(2, this.nov9Y2001);
         final SerialDate answer = SerialDate.createInstance(9, 1, 2002);
         assertEquals(answer, jan9Y2002);
     }
 
     /**
      * A test case for a reported bug, now fixed.
      */
     public void testAddMonthsTo5Oct2003() {
         final SerialDate d1 = SerialDate.createInstance(5, MonthConstants.OCTOBER, 2003);
         final SerialDate d2 = SerialDate.addMonths(2, d1);
         assertEquals(d2, SerialDate.createInstance(5, MonthConstants.DECEMBER, 2003));
     }
 
     /**
      * A test case for a reported bug, now fixed.
      */
     public void testAddMonthsTo1Jan2003() {
         final SerialDate d1 = SerialDate.createInstance(1, MonthConstants.JANUARY, 2003);
         final SerialDate d2 = SerialDate.addMonths(0, d1);
         assertEquals(d2, d1);
     }
 
     /**
      * Monday preceding Friday 9 November 2001 should be 5 November.
      */
     public void testMondayPrecedingFriday9Nov2001() {
         SerialDate mondayBefore = SerialDate.getPreviousDayOfWeek(
             SerialDate.MONDAY, this.nov9Y2001
         );
         assertEquals(5, mondayBefore.getDayOfMonth());
     }
 
     /**
      * Monday following Friday 9 November 2001 should be 12 November.
      */
     public void testMondayFollowingFriday9Nov2001() {
         SerialDate mondayAfter = SerialDate.getFollowingDayOfWeek(
             SerialDate.MONDAY, this.nov9Y2001
         );
         assertEquals(12, mondayAfter.getDayOfMonth());
     }
 
     /**
      * Monday nearest Friday 9 November 2001 should be 12 November.
      */
     public void testMondayNearestFriday9Nov2001() {
         SerialDate mondayNearest = SerialDate.getNearestDayOfWeek(
             SerialDate.MONDAY, this.nov9Y2001
         );
         assertEquals(12, mondayNearest.getDayOfMonth());
     }
 
     /**
      * The Monday nearest to 22nd January 1970 falls on the 19th.
      */
     public void testMondayNearest22Jan1970() {
         SerialDate jan22Y1970 = SerialDate.createInstance(22, MonthConstants.JANUARY, 1970);
         SerialDate mondayNearest = SerialDate.getNearestDayOfWeek(SerialDate.MONDAY, jan22Y1970);
         assertEquals(19, mondayNearest.getDayOfMonth());
     }
 
     /**
      * Problem that the conversion of days to strings returns the right result.  Actually, this 
      * result depends on the Locale so this test needs to be modified.
      */
     public void testWeekdayCodeToString() {
 
         final String test = SerialDate.weekdayCodeToString(SerialDate.SATURDAY);
         assertEquals("Saturday", test);
 
     }
 
     /**
      * Test the conversion of a string to a weekday.  Note that this test will fail if the 
      * default locale doesn't use English weekday names...devise a better test!
      */
     public void testStringToWeekday() {
 
         int weekday = SerialDate.stringToWeekdayCode("Wednesday");
         assertEquals(SerialDate.WEDNESDAY, weekday);
 
         weekday = SerialDate.stringToWeekdayCode(" Wednesday ");
         assertEquals(SerialDate.WEDNESDAY, weekday);
 
         weekday = SerialDate.stringToWeekdayCode("Wed");
         assertEquals(SerialDate.WEDNESDAY, weekday);
 
     }
 
     /**
      * Test the conversion of a string to a month.  Note that this test will fail if the default
      * locale doesn't use English month names...devise a better test!
      */
     public void testStringToMonthCode() {
 
         int m = SerialDate.stringToMonthCode("January");
         assertEquals(MonthConstants.JANUARY, m);
 
         m = SerialDate.stringToMonthCode(" January ");
         assertEquals(MonthConstants.JANUARY, m);
 
         m = SerialDate.stringToMonthCode("Jan");
         assertEquals(MonthConstants.JANUARY, m);
 
     }
 
     /**
      * Tests the conversion of a month code to a string.
      */
     public void testMonthCodeToStringCode() {
 
         final String test = SerialDate.monthCodeToString(MonthConstants.DECEMBER);
         assertEquals("December", test);
 
     }
 
     /**
      * 1900 is not a leap year.
      */
     public void testIsNotLeapYear1900() {
         assertTrue(!SerialDate.isLeapYear(1900));
     }
 
     /**
      * 2000 is a leap year.
      */
     public void testIsLeapYear2000() {
         assertTrue(SerialDate.isLeapYear(2000));
     }
 
     /**
      * The number of leap years from 1900 up-to-and-including 1899 is 0.
      */
     public void testLeapYearCount1899() {
         assertEquals(SerialDate.leapYearCount(1899), 0);
     }
 
     /**
      * The number of leap years from 1900 up-to-and-including 1903 is 0.
      */
     public void testLeapYearCount1903() {
         assertEquals(SerialDate.leapYearCount(1903), 0);
     }
 
     /**
      * The number of leap years from 1900 up-to-and-including 1904 is 1.
      */
     public void testLeapYearCount1904() {
         assertEquals(SerialDate.leapYearCount(1904), 1);
     }
 
     /**
      * The number of leap years from 1900 up-to-and-including 1999 is 24.
      */
     public void testLeapYearCount1999() {
         assertEquals(SerialDate.leapYearCount(1999), 24);
     }
 
     /**
      * The number of leap years from 1900 up-to-and-including 2000 is 25.
      */
     public void testLeapYearCount2000() {
         assertEquals(SerialDate.leapYearCount(2000), 25);
     }
 
     /**
      * Serialize an instance, restore it, and check for equality.
      */
     public void testSerialization() {
 
         SerialDate d1 = SerialDate.createInstance(15, 4, 2000);
         SerialDate d2 = null;
 
         try {
             ByteArrayOutputStream buffer = new ByteArrayOutputStream();
             ObjectOutput out = new ObjectOutputStream(buffer);
             out.writeObject(d1);
             out.close();
 
             ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));
             d2 = (SerialDate) in.readObject();
             in.close();
         }
         catch (Exception e) {
             System.out.println(e.toString());
         }
         assertEquals(d1, d2);
 
     }
     
     /**
      * A test for bug report 1096282 (now fixed).
      */
     public void test1096282() {
         SerialDate d = SerialDate.createInstance(29, 2, 2004);
         d = SerialDate.addYears(1, d);
         SerialDate expected = SerialDate.createInstance(28, 2, 2005);
         assertTrue(d.isOn(expected));
     }
 
     /**
      * Miscellaneous tests for the addMonths() method.
      */
     public void testAddMonths() {
         SerialDate d1 = SerialDate.createInstance(31, 5, 2004);
 
         SerialDate d2 = SerialDate.addMonths(1, d1);
         assertEquals(30, d2.getDayOfMonth());
         assertEquals(6, d2.getMonth());
         assertEquals(2004, d2.getYYYY());
 
         SerialDate d3 = SerialDate.addMonths(2, d1);
         assertEquals(31, d3.getDayOfMonth());
         assertEquals(7, d3.getMonth());
         assertEquals(2004, d3.getYYYY());
 
         SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1));
         assertEquals(30, d4.getDayOfMonth());
         assertEquals(7, d4.getMonth());
         assertEquals(2004, d4.getYYYY());
     }
 }
 
 //////////////////////////////////////////////
 
 /* ========================================================================
  * JCommon : a free general purpose class library for the Java(tm) platform
  * ========================================================================
  *
  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
  * 
  * Project Info:  http://www.jfree.org/jcommon/index.html
  *
  * This library is free software; you can redistribute it and/or modify it 
  * under the terms of the GNU Lesser General Public License as published by 
  * the Free Software Foundation; either version 2.1 of the License, or 
  * (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful, but 
  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
  * License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 
  * USA.  
  *
  * [Java is a trademark or registered trademark of Sun Microsystems, Inc. 
  * in the United States and other countries.]
  *
  * -------------------
  * MonthConstants.java
  * -------------------
  * (C) Copyright 2002, 2003, by Object Refinery Limited.
  *
  * Original Author:  David Gilbert (for Object Refinery Limited);
  * Contributor(s):   -;
  *
  * $Id: MonthConstants.java,v 1.3 2005/10/18 13:15:08 mungady Exp $
  *
  * Changes
  * -------
  * 29-May-2002 : Version 1 (code moved from SerialDate class) (DG);
  *
  */
 
 package org.jfree.date;
 
 /**
  * Useful constants for months.  Note that these are NOT equivalent to the
  * constants defined by java.util.Calendar (where JANUARY=0 and DECEMBER=11).
  * <P>
  * Used by the SerialDate and RegularTimePeriod classes.
  *
  * @author David Gilbert
  */
 public interface MonthConstants {
 
     /** Constant for January. */
     public static final int JANUARY = 1;
 
     /** Constant for February. */
     public static final int FEBRUARY = 2;
 
     /** Constant for March. */
     public static final int MARCH = 3;
 
     /** Constant for April. */
     public static final int APRIL = 4;
 
     /** Constant for May. */
     public static final int MAY = 5;
 
     /** Constant for June. */
     public static final int JUNE = 6;
 
     /** Constant for July. */
     public static final int JULY = 7;
 
     /** Constant for August. */
     public static final int AUGUST = 8;
 
     /** Constant for September. */
     public static final int SEPTEMBER = 9;
 
     /** Constant for October. */
     public static final int OCTOBER = 10;
 
     /** Constant for November. */
     public static final int NOVEMBER = 11;
 
     /** Constant for December. */
     public static final int DECEMBER = 12;
 
 }
 
 ////////////////////////////////////////////////
 
 package org.jfree.date.junit;
 
 import junit.framework.TestCase;
 import org.jfree.date.*;
 import static org.jfree.date.SerialDate.*;
 
 import java.util.*;
 
 public class BobsSerialDateTest extends TestCase {
 
   public void testIsValidWeekdayCode() throws Exception {
     for (int day = 1; day <= 7; day++)
       assertTrue(isValidWeekdayCode(day));
     assertFalse(isValidWeekdayCode(0));
     assertFalse(isValidWeekdayCode(8));
   }
 
   public void testStringToWeekdayCode() throws Exception {
 
     assertEquals(-1, stringToWeekdayCode("Hello"));
     assertEquals(MONDAY, stringToWeekdayCode("Monday"));
     assertEquals(MONDAY, stringToWeekdayCode("Mon"));
 //todo assertEquals(MONDAY,stringToWeekdayCode("monday"));
 // assertEquals(MONDAY,stringToWeekdayCode("MONDAY"));
 // assertEquals(MONDAY, stringToWeekdayCode("mon"));
 
     assertEquals(TUESDAY, stringToWeekdayCode("Tuesday"));
     assertEquals(TUESDAY, stringToWeekdayCode("Tue"));
 // assertEquals(TUESDAY,stringToWeekdayCode("tuesday"));
 // assertEquals(TUESDAY,stringToWeekdayCode("TUESDAY"));
 // assertEquals(TUESDAY, stringToWeekdayCode("tue"));
 // assertEquals(TUESDAY, stringToWeekdayCode("tues"));
 
     assertEquals(WEDNESDAY, stringToWeekdayCode("Wednesday"));
     assertEquals(WEDNESDAY, stringToWeekdayCode("Wed"));
 // assertEquals(WEDNESDAY,stringToWeekdayCode("wednesday"));
 // assertEquals(WEDNESDAY,stringToWeekdayCode("WEDNESDAY"));
 // assertEquals(WEDNESDAY, stringToWeekdayCode("wed"));
 
     assertEquals(THURSDAY, stringToWeekdayCode("Thursday"));
     assertEquals(THURSDAY, stringToWeekdayCode("Thu"));
 // assertEquals(THURSDAY,stringToWeekdayCode("thursday"));
 // assertEquals(THURSDAY,stringToWeekdayCode("THURSDAY"));
 // assertEquals(THURSDAY, stringToWeekdayCode("thu"));
 // assertEquals(THURSDAY, stringToWeekdayCode("thurs"));
 
     assertEquals(FRIDAY, stringToWeekdayCode("Friday"));
     assertEquals(FRIDAY, stringToWeekdayCode("Fri"));
 // assertEquals(FRIDAY,stringToWeekdayCode("friday"));
 // assertEquals(FRIDAY,stringToWeekdayCode("FRIDAY"));
 // assertEquals(FRIDAY, stringToWeekdayCode("fri"));
 
     assertEquals(SATURDAY, stringToWeekdayCode("Saturday"));
     assertEquals(SATURDAY, stringToWeekdayCode("Sat"));
 // assertEquals(SATURDAY,stringToWeekdayCode("saturday"));
 // assertEquals(SATURDAY,stringToWeekdayCode("SATURDAY"));
 // assertEquals(SATURDAY, stringToWeekdayCode("sat"));
 
     assertEquals(SUNDAY, stringToWeekdayCode("Sunday"));
     assertEquals(SUNDAY, stringToWeekdayCode("Sun"));
 // assertEquals(SUNDAY,stringToWeekdayCode("sunday"));
 // assertEquals(SUNDAY,stringToWeekdayCode("SUNDAY"));
 // assertEquals(SUNDAY, stringToWeekdayCode("sun"));
   }
 
   public void testWeekdayCodeToString() throws Exception {
     assertEquals("Sunday", weekdayCodeToString(SUNDAY));
     assertEquals("Monday", weekdayCodeToString(MONDAY));
     assertEquals("Tuesday", weekdayCodeToString(TUESDAY));
     assertEquals("Wednesday", weekdayCodeToString(WEDNESDAY));
     assertEquals("Thursday", weekdayCodeToString(THURSDAY));
     assertEquals("Friday", weekdayCodeToString(FRIDAY));
     assertEquals("Saturday", weekdayCodeToString(SATURDAY));
   }
 
   public void testIsValidMonthCode() throws Exception {
     for (int i = 1; i <= 12; i++)
       assertTrue(isValidMonthCode(i));
     assertFalse(isValidMonthCode(0));
     assertFalse(isValidMonthCode(13));
   }
 
   public void testMonthToQuarter() throws Exception {
     assertEquals(1, monthCodeToQuarter(JANUARY));
     assertEquals(1, monthCodeToQuarter(FEBRUARY));
     assertEquals(1, monthCodeToQuarter(MARCH));
     assertEquals(2, monthCodeToQuarter(APRIL));
     assertEquals(2, monthCodeToQuarter(MAY));
     assertEquals(2, monthCodeToQuarter(JUNE));
     assertEquals(3, monthCodeToQuarter(JULY));
     assertEquals(3, monthCodeToQuarter(AUGUST));
     assertEquals(3, monthCodeToQuarter(SEPTEMBER));
     assertEquals(4, monthCodeToQuarter(OCTOBER));
     assertEquals(4, monthCodeToQuarter(NOVEMBER));
     assertEquals(4, monthCodeToQuarter(DECEMBER));
     
     try {
       monthCodeToQuarter(-1);
       fail("Nieprawid�owy kod miesi�ca powinien wygenerowa� wyj�tek");
     } catch (IllegalArgumentException e) {
     }
   }
   
   public void testMonthCodeToString() throws Exception {
     assertEquals("January", monthCodeToString(JANUARY));
     assertEquals("February", monthCodeToString(FEBRUARY));
     assertEquals("March", monthCodeToString(MARCH));
     assertEquals("April", monthCodeToString(APRIL));
     assertEquals("May", monthCodeToString(MAY));
     assertEquals("June", monthCodeToString(JUNE));
     assertEquals("July", monthCodeToString(JULY));
     assertEquals("August", monthCodeToString(AUGUST));
     assertEquals("September", monthCodeToString(SEPTEMBER));
     assertEquals("October", monthCodeToString(OCTOBER));
     assertEquals("November", monthCodeToString(NOVEMBER));
     assertEquals("December", monthCodeToString(DECEMBER));
     
     assertEquals("Jan", monthCodeToString(JANUARY, true));
     assertEquals("Feb", monthCodeToString(FEBRUARY, true));
     assertEquals("Mar", monthCodeToString(MARCH, true));
     assertEquals("Apr", monthCodeToString(APRIL, true));
     assertEquals("May", monthCodeToString(MAY, true));
     assertEquals("Jun", monthCodeToString(JUNE, true));
     assertEquals("Jul", monthCodeToString(JULY, true));
     assertEquals("Aug", monthCodeToString(AUGUST, true));
     assertEquals("Sep", monthCodeToString(SEPTEMBER, true));
     assertEquals("Oct", monthCodeToString(OCTOBER, true));
     assertEquals("Nov", monthCodeToString(NOVEMBER, true));
     assertEquals("Dec", monthCodeToString(DECEMBER, true));
 
     try {
       monthCodeToString(-1);
       fail("Nieprawid�owy kod miesi�ca powinien wygenerowa� wyj�tek");
     } catch (IllegalArgumentException e) {
     }
 
   }
   
   public void testStringToMonthCode() throws Exception {
     assertEquals(JANUARY,stringToMonthCode("1"));
     assertEquals(FEBRUARY,stringToMonthCode("2"));
     assertEquals(MARCH,stringToMonthCode("3"));
     assertEquals(APRIL,stringToMonthCode("4"));
     assertEquals(MAY,stringToMonthCode("5"));
     assertEquals(JUNE,stringToMonthCode("6"));
     assertEquals(JULY,stringToMonthCode("7"));
     assertEquals(AUGUST,stringToMonthCode("8"));
     assertEquals(SEPTEMBER,stringToMonthCode("9"));
     assertEquals(OCTOBER,stringToMonthCode("10"));
     assertEquals(NOVEMBER, stringToMonthCode("11"));
     assertEquals(DECEMBER,stringToMonthCode("12"));
 
 //todo assertEquals(-1, stringToMonthCode("0"));
 // assertEquals(-1, stringToMonthCode("13"));
 
     assertEquals(-1,stringToMonthCode("Cze��"));
 
     for (int m = 1; m <= 12; m++) {
       assertEquals(m, stringToMonthCode(monthCodeToString(m, false)));
       assertEquals(m, stringToMonthCode(monthCodeToString(m, true)));
     }
 
 // assertEquals(1,stringToMonthCode("jan"));
 // assertEquals(2,stringToMonthCode("feb"));
 // assertEquals(3,stringToMonthCode("mar"));
 // assertEquals(4,stringToMonthCode("apr"));
 // assertEquals(5,stringToMonthCode("may"));
 // assertEquals(6,stringToMonthCode("jun"));
 // assertEquals(7,stringToMonthCode("jul"));
 // assertEquals(8,stringToMonthCode("aug"));
 // assertEquals(9,stringToMonthCode("sep"));
 // assertEquals(10,stringToMonthCode("oct"));
 // assertEquals(11,stringToMonthCode("nov"));
 // assertEquals(12,stringToMonthCode("dec"));
 
 // assertEquals(1,stringToMonthCode("JAN"));
 // assertEquals(2,stringToMonthCode("FEB"));
 // assertEquals(3,stringToMonthCode("MAR"));
 // assertEquals(4,stringToMonthCode("APR"));
 // assertEquals(5,stringToMonthCode("MAY"));
 // assertEquals(6,stringToMonthCode("JUN"));
 // assertEquals(7,stringToMonthCode("JUL"));
 // assertEquals(8,stringToMonthCode("AUG"));
 // assertEquals(9,stringToMonthCode("SEP"));
 // assertEquals(10,stringToMonthCode("OCT"));
 // assertEquals(11,stringToMonthCode("NOV"));
 // assertEquals(12,stringToMonthCode("DEC"));
 
 // assertEquals(1,stringToMonthCode("january"));
 // assertEquals(2,stringToMonthCode("february"));
 // assertEquals(3,stringToMonthCode("march"));
 // assertEquals(4,stringToMonthCode("april"));
 // assertEquals(5,stringToMonthCode("may"));
 // assertEquals(6,stringToMonthCode("june"));
 // assertEquals(7,stringToMonthCode("july"));
 // assertEquals(8,stringToMonthCode("august"));
 // assertEquals(9,stringToMonthCode("september"));
 // assertEquals(10,stringToMonthCode("october"));
 // assertEquals(11,stringToMonthCode("november"));
 // assertEquals(12,stringToMonthCode("december"));
 
 // assertEquals(1,stringToMonthCode("JANUARY"));
 // assertEquals(2,stringToMonthCode("FEBRUARY"));
 // assertEquals(3,stringToMonthCode("MAR"));
 // assertEquals(4,stringToMonthCode("APRIL"));
 // assertEquals(5,stringToMonthCode("MAY"));
 // assertEquals(6,stringToMonthCode("JUNE"));
 // assertEquals(7,stringToMonthCode("JULY"));
 // assertEquals(8,stringToMonthCode("AUGUST"));
 // assertEquals(9,stringToMonthCode("SEPTEMBER"));
 // assertEquals(10,stringToMonthCode("OCTOBER"));
 // assertEquals(11,stringToMonthCode("NOVEMBER"));
 // assertEquals(12,stringToMonthCode("DECEMBER"));
   }
   
   public void testIsValidWeekInMonthCode() throws Exception {
     for (int w = 0; w <= 4; w++) {
       assertTrue(isValidWeekInMonthCode(w));
     }
     assertFalse(isValidWeekInMonthCode(5));
   }
 
   public void testIsLeapYear() throws Exception {
     assertFalse(isLeapYear(1900));
     assertFalse(isLeapYear(1901));
     assertFalse(isLeapYear(1902));
     assertFalse(isLeapYear(1903));
     assertTrue(isLeapYear(1904));
     assertTrue(isLeapYear(1908));
     assertFalse(isLeapYear(1955));
     assertTrue(isLeapYear(1964));
     assertTrue(isLeapYear(1980));
     assertTrue(isLeapYear(2000));
     assertFalse(isLeapYear(2001));
     assertFalse(isLeapYear(2100));
   }
 
   public void testLeapYearCount() throws Exception {
     assertEquals(0, leapYearCount(1900));
     assertEquals(0, leapYearCount(1901));
     assertEquals(0, leapYearCount(1902));
     assertEquals(0, leapYearCount(1903));
     assertEquals(1, leapYearCount(1904));
     assertEquals(1, leapYearCount(1905));
     assertEquals(1, leapYearCount(1906));
     assertEquals(1, leapYearCount(1907));
     assertEquals(2, leapYearCount(1908));
     assertEquals(24, leapYearCount(1999));
     assertEquals(25, leapYearCount(2001));
     assertEquals(49, leapYearCount(2101));
     assertEquals(73, leapYearCount(2201));
     assertEquals(97, leapYearCount(2301));
     assertEquals(122, leapYearCount(2401));
   }
 
   public void testLastDayOfMonth() throws Exception {
     assertEquals(31, lastDayOfMonth(JANUARY, 1901));
     assertEquals(28, lastDayOfMonth(FEBRUARY, 1901));
     assertEquals(31, lastDayOfMonth(MARCH, 1901));
     assertEquals(30, lastDayOfMonth(APRIL, 1901));
     assertEquals(31, lastDayOfMonth(MAY, 1901));
     assertEquals(30, lastDayOfMonth(JUNE, 1901));
     assertEquals(31, lastDayOfMonth(JULY, 1901));
     assertEquals(31, lastDayOfMonth(AUGUST, 1901));
     assertEquals(30, lastDayOfMonth(SEPTEMBER, 1901));
     assertEquals(31, lastDayOfMonth(OCTOBER, 1901));
     assertEquals(30, lastDayOfMonth(NOVEMBER, 1901));
     assertEquals(31, lastDayOfMonth(DECEMBER, 1901));
     assertEquals(29, lastDayOfMonth(FEBRUARY, 1904));
   }
 
   public void testAddDays() throws Exception {
     SerialDate newYears = d(1, JANUARY, 1900);
     assertEquals(d(2, JANUARY, 1900), addDays(1, newYears));
     assertEquals(d(1, FEBRUARY, 1900), addDays(31, newYears));
     assertEquals(d(1, JANUARY, 1901), addDays(365, newYears));
     assertEquals(d(31, DECEMBER, 1904), addDays(5 * 365, newYears));
   }
 
   private static SpreadsheetDate d(int day, int month, int year) {return new SpreadsheetDate(day, month, year);}
 
   public void testAddMonths() throws Exception {
     assertEquals(d(1, FEBRUARY, 1900), addMonths(1, d(1, JANUARY, 1900)));
     assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(31, JANUARY, 1900)));
     assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(30, JANUARY, 1900)));
     assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(29, JANUARY, 1900)));
     assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(28, JANUARY, 1900)));
     assertEquals(d(27, FEBRUARY, 1900), addMonths(1, d(27, JANUARY, 1900)));
     
     assertEquals(d(30, JUNE, 1900), addMonths(5, d(31, JANUARY, 1900)));
     assertEquals(d(30, JUNE, 1901), addMonths(17, d(31, JANUARY, 1900)));
     
     assertEquals(d(29, FEBRUARY, 1904), addMonths(49, d(31, JANUARY, 1900)));
 
   }
 
   public void testAddYears() throws Exception {
     assertEquals(d(1, JANUARY, 1901), addYears(1, d(1, JANUARY, 1900)));
     assertEquals(d(28, FEBRUARY, 1905), addYears(1, d(29, FEBRUARY, 1904)));
     assertEquals(d(28, FEBRUARY, 1905), addYears(1, d(28, FEBRUARY, 1904)));
     assertEquals(d(28, FEBRUARY, 1904), addYears(1, d(28, FEBRUARY, 1903)));
   }
 
   public void testGetPreviousDayOfWeek() throws Exception {
     assertEquals(d(24, FEBRUARY, 2006), getPreviousDayOfWeek(FRIDAY, d(1, MARCH, 2006)));
     assertEquals(d(22, FEBRUARY, 2006), getPreviousDayOfWeek(WEDNESDAY, d(1, MARCH, 2006)));
     assertEquals(d(29, FEBRUARY, 2004), getPreviousDayOfWeek(SUNDAY, d(3, MARCH, 2004)));
     assertEquals(d(29, DECEMBER, 2004), getPreviousDayOfWeek(WEDNESDAY, d(5, JANUARY, 2005)));
     
     try {
       getPreviousDayOfWeek(-1, d(1, JANUARY, 2006));
       fail("Nieprawid�owy kod tygodnia powinien wygenerowa� wyj�tek");
     } catch (IllegalArgumentException e) {
     }
   }
 
   public void testGetFollowingDayOfWeek() throws Exception {
 // assertEquals(d(1, JANUARY, 2005),getFollowingDayOfWeek(SATURDAY, d(25, DECEMBER, 2004)));
     assertEquals(d(1, JANUARY, 2005), getFollowingDayOfWeek(SATURDAY, d(26, DECEMBER, 2004)));
     assertEquals(d(3, MARCH, 2004), getFollowingDayOfWeek(WEDNESDAY, d(28, FEBRUARY, 2004)));
     
     try {
       getFollowingDayOfWeek(-1, d(1, JANUARY, 2006));
       fail("Nieprawid�owy kod tygodnia powinien wygenerowa� wyj�tek");
     } catch (IllegalArgumentException e) {
     }
   }
   
   public void testGetNearestDayOfWeek() throws Exception {
     assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(16, APRIL, 2006)));
     assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(17, APRIL, 2006)));
     assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(18, APRIL, 2006)));
     assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(19, APRIL, 2006)));
     assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(20, APRIL, 2006)));
     assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(21, APRIL, 2006)));
     assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(22, APRIL, 2006)));
 
 //todo assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(16, APRIL, 2006)));
     assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(17, APRIL, 2006)));
     assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(18, APRIL, 2006)));
     assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(19, APRIL, 2006)));
     assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(20, APRIL, 2006)));
     assertEquals(d(24, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(21, APRIL, 2006)));
     assertEquals(d(24, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(22, APRIL, 2006)));
 
 // assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(16, APRIL, 2006)));
 // assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(17, APRIL, 2006)));
     assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(18, APRIL, 2006)));
     assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(19, APRIL, 2006)));
     assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(20, APRIL, 2006)));
     assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(21, APRIL, 2006)));
     assertEquals(d(25, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(22, APRIL, 2006)));
 
 // assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(16, APRIL, 2006)));
 // assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(17, APRIL, 2006)));
 // assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(18, APRIL, 2006)));
     assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(19, APRIL, 2006)));
     assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(20, APRIL, 2006)));
     assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(21, APRIL, 2006)));
     assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(22, APRIL, 2006)));
 
 // assertEquals(d(13, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(16, APRIL, 2006)));
 // assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(17, APRIL, 2006)));
 // assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(18, APRIL, 2006)));
 // assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(19, APRIL, 2006)));
     assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(20, APRIL, 2006)));
     assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(21, APRIL, 2006)));
     assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(22, APRIL, 2006)));
 
 // assertEquals(d(14, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(16, APRIL, 2006)));
 // assertEquals(d(14, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(17, APRIL, 2006)));
 // assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(18, APRIL, 2006)));
 // assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(19, APRIL, 2006)));
 // assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(20, APRIL, 2006)));
     assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(21, APRIL, 2006)));
     assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(22, APRIL, 2006)));
 
 // assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(16, APRIL, 2006)));
 // assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(17, APRIL, 2006)));
 // assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(18, APRIL, 2006)));
 // assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(19, APRIL, 2006)));
 // assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(20, APRIL, 2006)));
 // assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(21, APRIL, 2006)));
     assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(22, APRIL, 2006)));
 
     try {
       getNearestDayOfWeek(-1, d(1, JANUARY, 2006));
       fail("Nieprawid�owy kod tygodnia powinien wygenerowa� wyj�tek");
     } catch (IllegalArgumentException e) {
     }
   }
 
   public void testEndOfCurrentMonth() throws Exception {
     SerialDate d = SerialDate.createInstance(2);
     assertEquals(d(31, JANUARY, 2006), d.getEndOfCurrentMonth(d(1, JANUARY, 2006)));
     assertEquals(d(28, FEBRUARY, 2006), d.getEndOfCurrentMonth(d(1, FEBRUARY, 2006)));
     assertEquals(d(31, MARCH, 2006), d.getEndOfCurrentMonth(d(1, MARCH, 2006)));
     assertEquals(d(30, APRIL, 2006), d.getEndOfCurrentMonth(d(1, APRIL, 2006)));
     assertEquals(d(31, MAY, 2006), d.getEndOfCurrentMonth(d(1, MAY, 2006)));
     assertEquals(d(30, JUNE, 2006), d.getEndOfCurrentMonth(d(1, JUNE, 2006)));
     assertEquals(d(31, JULY, 2006), d.getEndOfCurrentMonth(d(1, JULY, 2006)));
     assertEquals(d(31, AUGUST, 2006), d.getEndOfCurrentMonth(d(1, AUGUST, 2006)));
     assertEquals(d(30, SEPTEMBER, 2006), d.getEndOfCurrentMonth(d(1, SEPTEMBER, 2006)));
     assertEquals(d(31, OCTOBER, 2006), d.getEndOfCurrentMonth(d(1, OCTOBER, 2006)));
     assertEquals(d(30, NOVEMBER, 2006), d.getEndOfCurrentMonth(d(1, NOVEMBER, 2006)));
     assertEquals(d(31, DECEMBER, 2006), d.getEndOfCurrentMonth(d(1, DECEMBER, 2006)));
     assertEquals(d(29, FEBRUARY, 2008), d.getEndOfCurrentMonth(d(1, FEBRUARY, 2008)));
   }
 
   public void testWeekInMonthToString() throws Exception {
     assertEquals("First",weekInMonthToString(FIRST_WEEK_IN_MONTH));
     assertEquals("Second",weekInMonthToString(SECOND_WEEK_IN_MONTH));
     assertEquals("Third",weekInMonthToString(THIRD_WEEK_IN_MONTH));
     assertEquals("Fourth",weekInMonthToString(FOURTH_WEEK_IN_MONTH));
     assertEquals("Last",weekInMonthToString(LAST_WEEK_IN_MONTH));
 
 //todo try {
 // weekInMonthToString(-1);
 // fail("Nieprawid�owy kod tygodnia powinien wygenerowa� wyj�tek");
 // } catch (IllegalArgumentException e) {
 // }
   }
 
   public void testRelativeToString() throws Exception {
     assertEquals("Preceding",relativeToString(PRECEDING));
     assertEquals("Nearest",relativeToString(NEAREST));
     assertEquals("Following",relativeToString(FOLLOWING));
 
 //todo try {
 // relativeToString(-1000);
 // fail("Nieprawid�owy kod wzgl�dny powinien wygenerowa� wyj�tek");
 // } catch (IllegalArgumentException e) {
 // }
   }
 
   public void testCreateInstanceFromDDMMYYY() throws Exception {
     SerialDate date = createInstance(1, JANUARY, 1900);
     assertEquals(1,date.getDayOfMonth());
     assertEquals(JANUARY,date.getMonth());
     assertEquals(1900,date.getYYYY());
     assertEquals(2,date.toSerial());
   }
 
   public void testCreateInstanceFromSerial() throws Exception {
     assertEquals(d(1, JANUARY, 1900),createInstance(2));
     assertEquals(d(1, JANUARY, 1901), createInstance(367));
   }
 
   public void testCreateInstanceFromJavaDate() throws Exception {
     assertEquals(d(1, JANUARY, 1900),createInstance(new GregorianCalendar(1900,0,1).getTime()));
     assertEquals(d(1, JANUARY, 2006),createInstance(new GregorianCalendar(2006,0,1).getTime()));
   }
 
   public static void main(String[] args) {
     junit.textui.TestRunner.run(BobsSerialDateTest.class);
   }
 }
 
 //////////////////////////////////////////////
 
 /* ========================================================================
  * JCommon : a free general purpose class library for the Java(tm) platform
  * ========================================================================
  *
  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
  * 
  * Project Info:  http://www.jfree.org/jcommon/index.html
  *
  * This library is free software; you can redistribute it and/or modify it 
  * under the terms of the GNU Lesser General Public License as published by 
  * the Free Software Foundation; either version 2.1 of the License, or 
  * (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful, but 
  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
  * License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 
  * USA.  
  *
  * [Java is a trademark or registered trademark of Sun Microsystems, Inc. 
  * in the United States and other countries.]
  *
  * --------------------
  * SpreadsheetDate.java
  * --------------------
  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
  *
  * Original Author:  David Gilbert (for Object Refinery Limited);
  * Contributor(s):   -;
  *
  * $Id: SpreadsheetDate.java,v 1.8 2005/11/03 09:25:39 mungady Exp $
  *
  * Changes
  * -------
  * 11-Oct-2001 : Version 1 (DG);
  * 05-Nov-2001 : Added getDescription() and setDescription() methods (DG);
  * 12-Nov-2001 : Changed name from ExcelDate.java to SpreadsheetDate.java (DG);
  *               Fixed a bug in calculating day, month and year from serial 
  *               number (DG);
  * 24-Jan-2002 : Fixed a bug in calculating the serial number from the day, 
  *               month and year.  Thanks to Trevor Hills for the report (DG);
  * 29-May-2002 : Added equals(Object) method (SourceForge ID 558850) (DG);
  * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG);
  * 13-Mar-2003 : Implemented Serializable (DG);
  * 04-Sep-2003 : Completed isInRange() methods (DG);
  * 05-Sep-2003 : Implemented Comparable (DG);
  * 21-Oct-2003 : Added hashCode() method (DG);
  *
  */
 
 package org.jfree.date;
 
 import java.util.Calendar;
 import java.util.Date;
 
 /**
  * Represents a date using an integer, in a similar fashion to the
  * implementation in Microsoft Excel.  The range of dates supported is
  * 1-Jan-1900 to 31-Dec-9999.
  * <P>
  * Be aware that there is a deliberate bug in Excel that recognises the year
  * 1900 as a leap year when in fact it is not a leap year. You can find more
  * information on the Microsoft website in article Q181370:
  * <P>
  * http://support.microsoft.com/support/kb/articles/Q181/3/70.asp
  * <P>
  * Excel uses the convention that 1-Jan-1900 = 1.  This class uses the
  * convention 1-Jan-1900 = 2.
  * The result is that the day number in this class will be different to the
  * Excel figure for January and February 1900...but then Excel adds in an extra
  * day (29-Feb-1900 which does not actually exist!) and from that point forward
  * the day numbers will match.
  *
  * @author David Gilbert
  */
 public class SpreadsheetDate extends SerialDate {
 
     /** For serialization. */
     private static final long serialVersionUID = -2039586705374454461L;
     
     /** 
      * The day number (1-Jan-1900 = 2, 2-Jan-1900 = 3, ..., 31-Dec-9999 = 
      * 2958465). 
      */
     private int serial;
 
     /** The day of the month (1 to 28, 29, 30 or 31 depending on the month). */
     private int day;
 
     /** The month of the year (1 to 12). */
     private int month;
 
     /** The year (1900 to 9999). */
     private int year;
 
     /** An optional description for the date. */
     private String description;
 
     /**
      * Creates a new date instance.
      *
      * @param day  the day (in the range 1 to 28/29/30/31).
      * @param month  the month (in the range 1 to 12).
      * @param year  the year (in the range 1900 to 9999).
      */
     public SpreadsheetDate(final int day, final int month, final int year) {
 
         if ((year >= 1900) && (year <= 9999)) {
             this.year = year;
         }
         else {
             throw new IllegalArgumentException(
                 "The 'year' argument must be in range 1900 to 9999."
             );
         }
 
         if ((month >= MonthConstants.JANUARY) 
                 && (month <= MonthConstants.DECEMBER)) {
             this.month = month;
         }
         else {
             throw new IllegalArgumentException(
                 "The 'month' argument must be in the range 1 to 12."
             );
         }
 
         if ((day >= 1) && (day <= SerialDate.lastDayOfMonth(month, year))) {
             this.day = day;
         }
         else {
             throw new IllegalArgumentException("Invalid 'day' argument.");
         }
 
         // the serial number needs to be synchronised with the day-month-year...
         this.serial = calcSerial(day, month, year);
 
         this.description = null;
 
     }
 
     /**
      * Standard constructor - creates a new date object representing the
      * specified day number (which should be in the range 2 to 2958465.
      *
      * @param serial  the serial number for the day (range: 2 to 2958465).
      */
     public SpreadsheetDate(final int serial) {
 
         if ((serial >= SERIAL_LOWER_BOUND) && (serial <= SERIAL_UPPER_BOUND)) {
             this.serial = serial;
         }
         else {
             throw new IllegalArgumentException(
                 "SpreadsheetDate: Serial must be in range 2 to 2958465.");
         }
 
         // the day-month-year needs to be synchronised with the serial number...
         calcDayMonthYear();
 
     }
 
     /**
      * Returns the description that is attached to the date.  It is not 
      * required that a date have a description, but for some applications it 
      * is useful.
      *
      * @return The description that is attached to the date.
      */
     public String getDescription() {
         return this.description;
     }
 
     /**
      * Sets the description for the date.
      *
      * @param description  the description for this date (<code>null</code> 
      *                     permitted).
      */
     public void setDescription(final String description) {
         this.description = description;
     }
 
     /**
      * Returns the serial number for the date, where 1 January 1900 = 2
      * (this corresponds, almost, to the numbering system used in Microsoft
      * Excel for Windows and Lotus 1-2-3).
      *
      * @return The serial number of this date.
      */
     public int toSerial() {
         return this.serial;
     }
 
     /**
      * Returns a <code>java.util.Date</code> equivalent to this date.
      *
      * @return The date.
      */
     public Date toDate() {
         final Calendar calendar = Calendar.getInstance();
         calendar.set(getYYYY(), getMonth() - 1, getDayOfMonth(), 0, 0, 0);
         return calendar.getTime();
     }
 
     /**
      * Returns the year (assume a valid range of 1900 to 9999).
      *
      * @return The year.
      */
     public int getYYYY() {
         return this.year;
     }
 
     /**
      * Returns the month (January = 1, February = 2, March = 3).
      *
      * @return The month of the year.
      */
     public int getMonth() {
         return this.month;
     }
 
     /**
      * Returns the day of the month.
      *
      * @return The day of the month.
      */
     public int getDayOfMonth() {
         return this.day;
     }
 
     /**
      * Returns a code representing the day of the week.
      * <P>
      * The codes are defined in the {@link SerialDate} class as: 
      * <code>SUNDAY</code>, <code>MONDAY</code>, <code>TUESDAY</code>, 
      * <code>WEDNESDAY</code>, <code>THURSDAY</code>, <code>FRIDAY</code>, and 
      * <code>SATURDAY</code>.
      *
      * @return A code representing the day of the week.
      */
     public int getDayOfWeek() {
         return (this.serial + 6) % 7 + 1;
     }
 
     /**
      * Tests the equality of this date with an arbitrary object.
      * <P>
      * This method will return true ONLY if the object is an instance of the
      * {@link SerialDate} base class, and it represents the same day as this
      * {@link SpreadsheetDate}.
      *
      * @param object  the object to compare (<code>null</code> permitted).
      *
      * @return A boolean.
      */
     public boolean equals(final Object object) {
 
         if (object instanceof SerialDate) {
             final SerialDate s = (SerialDate) object;
             return (s.toSerial() == this.toSerial());
         }
         else {
             return false;
         }
 
     }
 
     /**
      * Returns a hash code for this object instance.
      * 
      * @return A hash code.
      */
     public int hashCode() {
         return toSerial();
     }
 
     /**
      * Returns the difference (in days) between this date and the specified 
      * 'other' date.
      *
      * @param other  the date being compared to.
      *
      * @return The difference (in days) between this date and the specified 
      *         'other' date.
      */
     public int compare(final SerialDate other) {
         return this.serial - other.toSerial();
     }
 
     /**
      * Implements the method required by the Comparable interface.
      * 
      * @param other  the other object (usually another SerialDate).
      * 
      * @return A negative integer, zero, or a positive integer as this object 
      *         is less than, equal to, or greater than the specified object.
      */
     public int compareTo(final Object other) {
         return compare((SerialDate) other);    
     }
     
     /**
      * Returns true if this SerialDate represents the same date as the
      * specified SerialDate.
      *
      * @param other  the date being compared to.
      *
      * @return <code>true</code> if this SerialDate represents the same date as
      *         the specified SerialDate.
      */
     public boolean isOn(final SerialDate other) {
         return (this.serial == other.toSerial());
     }
 
     /**
      * Returns true if this SerialDate represents an earlier date compared to
      * the specified SerialDate.
      *
      * @param other  the date being compared to.
      *
      * @return <code>true</code> if this SerialDate represents an earlier date
      *         compared to the specified SerialDate.
      */
     public boolean isBefore(final SerialDate other) {
         return (this.serial < other.toSerial());
     }
 
     /**
      * Returns true if this SerialDate represents the same date as the
      * specified SerialDate.
      *
      * @param other  the date being compared to.
      *
      * @return <code>true</code> if this SerialDate represents the same date
      *         as the specified SerialDate.
      */
     public boolean isOnOrBefore(final SerialDate other) {
         return (this.serial <= other.toSerial());
     }
 
     /**
      * Returns true if this SerialDate represents the same date as the
      * specified SerialDate.
      *
      * @param other  the date being compared to.
      *
      * @return <code>true</code> if this SerialDate represents the same date
      *         as the specified SerialDate.
      */
     public boolean isAfter(final SerialDate other) {
         return (this.serial > other.toSerial());
     }
 
     /**
      * Returns true if this SerialDate represents the same date as the
      * specified SerialDate.
      *
      * @param other  the date being compared to.
      *
      * @return <code>true</code> if this SerialDate represents the same date as
      *         the specified SerialDate.
      */
     public boolean isOnOrAfter(final SerialDate other) {
         return (this.serial >= other.toSerial());
     }
 
     /**
      * Returns <code>true</code> if this {@link SerialDate} is within the 
      * specified range (INCLUSIVE).  The date order of d1 and d2 is not 
      * important.
      *
      * @param d1  a boundary date for the range.
      * @param d2  the other boundary date for the range.
      *
      * @return A boolean.
      */
     public boolean isInRange(final SerialDate d1, final SerialDate d2) {
         return isInRange(d1, d2, SerialDate.INCLUDE_BOTH);
     }
 
     /**
      * Returns true if this SerialDate is within the specified range (caller
      * specifies whether or not the end-points are included).  The order of d1
      * and d2 is not important.
      *
      * @param d1  one boundary date for the range.
      * @param d2  a second boundary date for the range.
      * @param include  a code that controls whether or not the start and end 
      *                 dates are included in the range.
      *
      * @return <code>true</code> if this SerialDate is within the specified 
      *         range.
      */
     public boolean isInRange(final SerialDate d1, final SerialDate d2, 
                              final int include) {
         final int s1 = d1.toSerial();
         final int s2 = d2.toSerial();
         final int start = Math.min(s1, s2);
         final int end = Math.max(s1, s2);
         
         final int s = toSerial();
         if (include == SerialDate.INCLUDE_BOTH) {
             return (s >= start && s <= end);
         }
         else if (include == SerialDate.INCLUDE_FIRST) {
             return (s >= start && s < end);            
         }
         else if (include == SerialDate.INCLUDE_SECOND) {
             return (s > start && s <= end);            
         }
         else {
             return (s > start && s < end);            
         }    
     }
 
     /**
      * Calculate the serial number from the day, month and year.
      * <P>
      * 1-Jan-1900 = 2.
      *
      * @param d  the day.
      * @param m  the month.
      * @param y  the year.
      *
      * @return the serial number from the day, month and year.
      */
     private int calcSerial(final int d, final int m, final int y) {
         final int yy = ((y - 1900) * 365) + SerialDate.leapYearCount(y - 1);
         int mm = SerialDate.AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[m];
         if (m > MonthConstants.FEBRUARY) {
             if (SerialDate.isLeapYear(y)) {
                 mm = mm + 1;
             }
         }
         final int dd = d;
         return yy + mm + dd + 1;
     }
 
     /**
      * Calculate the day, month and year from the serial number.
      */
     private void calcDayMonthYear() {
 
         // get the year from the serial date
         final int days = this.serial - SERIAL_LOWER_BOUND;
         // overestimated because we ignored leap days
         final int overestimatedYYYY = 1900 + (days / 365);
         final int leaps = SerialDate.leapYearCount(overestimatedYYYY);
         final int nonleapdays = days - leaps;
         // underestimated because we overestimated years
         int underestimatedYYYY = 1900 + (nonleapdays / 365);
 
         if (underestimatedYYYY == overestimatedYYYY) {
             this.year = underestimatedYYYY;
         }
         else {
             int ss1 = calcSerial(1, 1, underestimatedYYYY);
             while (ss1 <= this.serial) {
                 underestimatedYYYY = underestimatedYYYY + 1;
                 ss1 = calcSerial(1, 1, underestimatedYYYY);
             }
             this.year = underestimatedYYYY - 1;
         }
 
         final int ss2 = calcSerial(1, 1, this.year);
 
         int[] daysToEndOfPrecedingMonth 
             = AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH;
 
         if (isLeapYear(this.year)) {
             daysToEndOfPrecedingMonth 
                 = LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH;
         }
 
         // get the month from the serial date
         int mm = 1;
         int sss = ss2 + daysToEndOfPrecedingMonth[mm] - 1;
         while (sss < this.serial) {
             mm = mm + 1;
             sss = ss2 + daysToEndOfPrecedingMonth[mm] - 1;
         }
         this.month = mm - 1;
 
         // what's left is d(+1);
         this.day = this.serial - ss2 
                    - daysToEndOfPrecedingMonth[this.month] + 1;
 
     }
 
 }
 
 ///////////////////////////////////////
 
 /* ========================================================================
  * JCommon : a free general purpose class library for the Java(tm) platform
  * ========================================================================
  *
  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
  * 
  * Project Info:  http://www.jfree.org/jcommon/index.html
  *
  * This library is free software; you can redistribute it and/or modify it 
  * under the terms of the GNU Lesser General Public License as published by 
  * the Free Software Foundation; either version 2.1 of the License, or 
  * (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful, but 
  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
  * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
  * License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 
  * USA.  
  *
  * [Java is a trademark or registered trademark of Sun Microsystems, Inc. 
  * in the United States and other countries.]
  *
  * --------------------------
  * RelativeDayOfWeekRule.java
  * --------------------------
  * (C) Copyright 2000-2003, by Object Refinery Limited and Contributors.
  *
  * Original Author:  David Gilbert (for Object Refinery Limited);
  * Contributor(s):   -;
  *
  * $Id: RelativeDayOfWeekRule.java,v 1.5 2005/11/03 09:24:45 mungady Exp $
  *
  * Changes (from 26-Oct-2001)
  * --------------------------
  * 26-Oct-2001 : Changed package to com.jrefinery.date.*;
  * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG);
  *
  */
 
 package org.jfree.date;
 
 /**
  * An annual date rule that returns a date for each year based on (a) a
  * reference rule; (b) a day of the week; and (c) a selection parameter
  * (SerialDate.PRECEDING, SerialDate.NEAREST, SerialDate.FOLLOWING).
  * <P>
  * For example, Good Friday can be specified as 'the Friday PRECEDING Easter 
  * Sunday'.
  *
  * @author David Gilbert
  */
 public class RelativeDayOfWeekRule extends AnnualDateRule {
 
     /** A reference to the annual date rule on which this rule is based. */
     private AnnualDateRule subrule;
 
     /** 
      * The day of the week (SerialDate.MONDAY, SerialDate.TUESDAY, and so on). 
      */
     private int dayOfWeek;
 
     /** Specifies which day of the week (PRECEDING, NEAREST or FOLLOWING). */
     private int relative;
 
     /**
      * Default constructor - builds a rule for the Monday following 1 January.
      */
     public RelativeDayOfWeekRule() {
         this(new DayAndMonthRule(), SerialDate.MONDAY, SerialDate.FOLLOWING);
     }
 
     /**
      * Standard constructor - builds rule based on the supplied sub-rule.
      *
      * @param subrule  the rule that determines the reference date.
      * @param dayOfWeek  the day-of-the-week relative to the reference date.
      * @param relative  indicates *which* day-of-the-week (preceding, nearest 
      *                  or following).
      */
     public RelativeDayOfWeekRule(final AnnualDateRule subrule, 
             final int dayOfWeek, final int relative) {
         this.subrule = subrule;
         this.dayOfWeek = dayOfWeek;
         this.relative = relative;
     }
 
     /**
      * Returns the sub-rule (also called the reference rule).
      *
      * @return The annual date rule that determines the reference date for this 
      *         rule.
      */
     public AnnualDateRule getSubrule() {
         return this.subrule;
     }
 
     /**
      * Sets the sub-rule.
      *
      * @param subrule  the annual date rule that determines the reference date 
      *                 for this rule.
      */
     public void setSubrule(final AnnualDateRule subrule) {
         this.subrule = subrule;
     }
 
     /**
      * Returns the day-of-the-week for this rule.
      *
      * @return the day-of-the-week for this rule.
      */
     public int getDayOfWeek() {
         return this.dayOfWeek;
     }
 
     /**
      * Sets the day-of-the-week for this rule.
      *
      * @param dayOfWeek  the day-of-the-week (SerialDate.MONDAY, 
      *                   SerialDate.TUESDAY, and so on).
      */
     public void setDayOfWeek(final int dayOfWeek) {
         this.dayOfWeek = dayOfWeek;
     }
 
     /**
      * Returns the 'relative' attribute, that determines *which* 
      * day-of-the-week we are interested in (SerialDate.PRECEDING, 
      * SerialDate.NEAREST or SerialDate.FOLLOWING).
      *
      * @return The 'relative' attribute.
      */
     public int getRelative() {
         return this.relative;
     }
 
     /**
      * Sets the 'relative' attribute (SerialDate.PRECEDING, SerialDate.NEAREST,
      * SerialDate.FOLLOWING).
      *
      * @param relative  determines *which* day-of-the-week is selected by this 
      *                  rule.
      */
     public void setRelative(final int relative) {
         this.relative = relative;
     }
 
     /**
      * Creates a clone of this rule.
      *
      * @return a clone of this rule.
      *
      * @throws CloneNotSupportedException this should never happen.
      */
     public Object clone() throws CloneNotSupportedException {
         final RelativeDayOfWeekRule duplicate 
             = (RelativeDayOfWeekRule) super.clone();
         duplicate.subrule = (AnnualDateRule) duplicate.getSubrule().clone();
         return duplicate;
     }
 
     /**
      * Returns the date generated by this rule, for the specified year.
      *
      * @param year  the year (1900 &lt;= year &lt;= 9999).
      *
      * @return The date generated by the rule for the given year (possibly 
      *         <code>null</code>).
      */
     public SerialDate getDate(final int year) {
 
         // check argument...
         if ((year < SerialDate.MINIMUM_YEAR_SUPPORTED)
             || (year > SerialDate.MAXIMUM_YEAR_SUPPORTED)) {
             throw new IllegalArgumentException(
                 "RelativeDayOfWeekRule.getDate(): year outside valid range.");
         }
 
         // calculate the date...
         SerialDate result = null;
         final SerialDate base = this.subrule.getDate(year);
 
         if (base != null) {
             switch (this.relative) {
                 case(SerialDate.PRECEDING):
                     result = SerialDate.getPreviousDayOfWeek(this.dayOfWeek, 
                             base);
                     break;
                 case(SerialDate.NEAREST):
                     result = SerialDate.getNearestDayOfWeek(this.dayOfWeek, 
                             base);
                     break;
                 case(SerialDate.FOLLOWING):
                     result = SerialDate.getFollowingDayOfWeek(this.dayOfWeek, 
                             base);
                     break;
                 default:
                     break;
             }
         }
         return result;
 
     }
 
 }
 
 ///////////////////////////////////////
 
 /* ========================================================================
 * JCommon : a free general purpose class library for the Java(tm) platform
 * ========================================================================
 *
 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
 ...
 */
 package org.jfree.date;
 
 import java.io.Serializable;
 import java.util.*;
 
 /**
 * Klasa abstrakcyjna, kt�ra reprezentuje niezmienne daty z dok�adno�ci�
 * do jednego dnia. Implementacja odwzorowuje ka�dy dzie� na liczb� integer
 * reprezentuj�c� kolejny dzie� od pewnego dnia pocz�tkowego.
 *
 * Dlaczego nie skorzysta� po prostu z java.util.Date? Robimy to, gdy ma to sens.
 * Czasami java.util.Date mo�e by� *zbyt* dok�adna - reprezentuje czas,
 * z dok�adno�ci� do 1/1000 sekundy (a sama data jest zale�na od stref czasowej)
 * Czasami chcemy reprezentowa� okreslony dzie� (np. 21 stycznia 2015)
 * bez zajmowania si� czasem w tym dniu, stref� czasow�
 * czy te� innymi parametrami. Do tego w�a�nie wykorzystujemy DayDate.
 *
 * Do utworzenia obiektu u�ywa� DayDateFactory.makeDate.
 *
 * @author David Gilbert
 * @author Robert C. Martin znacznie przebudowa� kod.
 */
 
 public abstract class DayDate implements Comparable, Serializable {
   public abstract int getOrdinalDay();
   public abstract int getYear();
   public abstract Month getMonth();
   public abstract int getDayOfMonth();
   
   protected abstract Day getDayOfWeekForOrdinalZero();
   
   public DayDate plusDays(int days) {
     return DayDateFactory.makeDate(getOrdinalDay() + days);
   }
 
   public DayDate plusMonths(int months) {
     int thisMonthAsOrdinal = getMonth().toInt() - Month.JANUARY.toInt();
     int thisMonthAndYearAsOrdinal = 12 * getYear() + thisMonthAsOrdinal;
     int resultMonthAndYearAsOrdinal = thisMonthAndYearAsOrdinal + months;
     int resultYear = resultMonthAndYearAsOrdinal / 12;
     int resultMonthAsOrdinal = resultMonthAndYearAsOrdinal % 12 + Month.JANUARY.toInt();
     Month resultMonth = Month.fromInt(resultMonthAsOrdinal);
     int resultDay = correctLastDayOfMonth(getDayOfMonth(), resultMonth, resultYear);
     return DayDateFactory.makeDate(resultDay, resultMonth, resultYear);
   }
 
   public DayDate plusYears(int years) {
     int resultYear = getYear() + years;
     int resultDay = correctLastDayOfMonth(getDayOfMonth(), getMonth(), resultYear);
     return DayDateFactory.makeDate(resultDay, getMonth(), resultYear);
   }
 
   private int correctLastDayOfMonth(int day, Month month, int year) {
     int lastDayOfMonth = DateUtil.lastDayOfMonth(month, year);
     if (day > lastDayOfMonth)
       day = lastDayOfMonth;
     return day;
   }
 
   public DayDate getPreviousDayOfWeek(Day targetDayOfWeek) {
     int offsetToTarget = targetDayOfWeek.toInt() - getDayOfWeek().toInt();
     if (offsetToTarget >= 0)
       offsetToTarget -= 7;
     return plusDays(offsetToTarget);
   }
 
   public DayDate getFollowingDayOfWeek(Day targetDayOfWeek) {
     int offsetToTarget = targetDayOfWeek.toInt() - getDayOfWeek().toInt();
     if (offsetToTarget <= 0)
       offsetToTarget += 7;
     return plusDays(offsetToTarget);
   }
 
   public DayDate getNearestDayOfWeek(Day targetDayOfWeek) {
     int offsetToThisWeeksTarget = targetDayOfWeek.toInt() - getDayOfWeek().toInt();
     int offsetToFutureTarget = (offsetToThisWeeksTarget + 7) % 7;
     int offsetToPreviousTarget = offsetToFutureTarget - 7;
     
     if (offsetToFutureTarget > 3)
       return plusDays(offsetToPreviousTarget);
     else
       return plusDays(offsetToFutureTarget);
   }
 
   public DayDate getEndOfMonth() {
     Month month = getMonth();
     int year = getYear();
     int lastDay = DateUtil.lastDayOfMonth(month, year);
     return DayDateFactory.makeDate(lastDay, month, year);
   }
 
   public Date toDate() {
     final Calendar calendar = Calendar.getInstance();
     int ordinalMonth = getMonth().toInt() - Month.JANUARY.toInt();
     calendar.set(getYear(), ordinalMonth, getDayOfMonth(), 0, 0, 0);
     return calendar.getTime();
   }
 
   public String toString() {
     return String.format("%02d-%s-%d", getDayOfMonth(), getMonth(), getYear());
   }
 
   public Day getDayOfWeek() {
     Day startingDay = getDayOfWeekForOrdinalZero();
     int startingOffset = startingDay.toInt() - Day.SUNDAY.toInt();
     int ordinalOfDayOfWeek = (getOrdinalDay() + startingOffset) % 7;
     return Day.fromInt(ordinalOfDayOfWeek + Day.SUNDAY.toInt());
   }
 
   public int daysSince(DayDate date) {
     return getOrdinalDay() - date.getOrdinalDay();
   }
 
   public boolean isOn(DayDate other) {
     return getOrdinalDay() == other.getOrdinalDay();
   }
 
   public boolean isBefore(DayDate other) {
     return getOrdinalDay() < other.getOrdinalDay();
   }
 
   public boolean isOnOrBefore(DayDate other) {
     return getOrdinalDay() <= other.getOrdinalDay();
   }
 
   public boolean isAfter(DayDate other) {
     return getOrdinalDay() > other.getOrdinalDay();
   }
 
   public boolean isOnOrAfter(DayDate other) {
     return getOrdinalDay() >= other.getOrdinalDay();
   }
 
   public boolean isInRange(DayDate d1, DayDate d2) {
     return isInRange(d1, d2, DateInterval.CLOSED);
   }
 
   public boolean isInRange(DayDate d1, DayDate d2, DateInterval interval) {
     int left = Math.min(d1.getOrdinalDay(), d2.getOrdinalDay());
     int right = Math.max(d1.getOrdinalDay(), d2.getOrdinalDay());
     return interval.isIn(getOrdinalDay(), left, right);
   }
 }
 
 /////////////////////////////////////////////
 
 package org.jfree.date;
 
 import java.text.DateFormatSymbols;
 
 public enum Month {
   JANUARY(1), FEBRUARY(2), MARCH(3),
   APRIL(4),   MAY(5),      JUNE(6),
   JULY(7),    AUGUST(8),   SEPTEMBER(9),
   OCTOBER(10),NOVEMBER(11),DECEMBER(12);
   private static DateFormatSymbols dateFormatSymbols = new DateFormatSymbols();
   private static final int[] LAST_DAY_OF_MONTH =
   {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
 
   private int index;
 
   Month(int index) {
     this.index = index;
   }
 
   public static Month fromInt(int monthIndex) {
     for (Month m : Month.values()) {
       if (m.index == monthIndex)
         return m;
     }
     throw new IllegalArgumentException("Niew�a�ciwy indeks miesi�ca " + monthIndex);
   }
 
   public int lastDay() {
     return LAST_DAY_OF_MONTH[index];
   }
 
   public int quarter() {
     return 1 + (index - 1) / 3;
   }
 
   public String toString() {
     return dateFormatSymbols.getMonths()[index - 1];
   }
 
   public String toShortString() {
     return dateFormatSymbols.getShortMonths()[index - 1];
   }
   
   public static Month parse(String s) {
     s = s.trim();
     for (Month m : Month.values())
       if (m.matches(s))
         return m;
 
     try {
       return fromInt(Integer.parseInt(s));
     }
     catch (NumberFormatException e) {}
       throw new IllegalArgumentException("Nieprawid�owy miesi�c " + s);
   }
 
   private boolean matches(String s) {
     return s.equalsIgnoreCase(toString()) ||
     s.equalsIgnoreCase(toShortString());
   }
 
   public int toInt() {
     return index;
   }
 }
 
 /////////////////////////////////////////
 
 package org.jfree.date;
 
 import java.util.Calendar;
 import java.text.DateFormatSymbols;
 
 public enum Day {
   MONDAY(Calendar.MONDAY),
   TUESDAY(Calendar.TUESDAY),
   WEDNESDAY(Calendar.WEDNESDAY),
   THURSDAY(Calendar.THURSDAY),
   FRIDAY(Calendar.FRIDAY),
   SATURDAY(Calendar.SATURDAY),
   SUNDAY(Calendar.SUNDAY);
 
   private final int index;
   private static DateFormatSymbols dateSymbols = new DateFormatSymbols();
 
   Day(int day) {
     index = day;
   }
 
   public static Day fromInt(int index) throws IllegalArgumentException {
     for (Day d : Day.values())
       if (d.index == index)
         return d;
     throw new IllegalArgumentException(
       String.format("Nieprawid�owy indeks dnia: %d.", index));
   }
 
   public static Day parse(String s) throws IllegalArgumentException {
     String[] shortWeekdayNames =
     dateSymbols.getShortWeekdays();
     String[] weekDayNames =
     dateSymbols.getWeekdays();
     
     s = s.trim();
     for (Day day : Day.values()) {
       if (s.equalsIgnoreCase(shortWeekdayNames[day.index]) ||
           s.equalsIgnoreCase(weekDayNames[day.index])) {
         return day;
       }
     }
     throw new IllegalArgumentException(
     String.format("%s nie jest prawid�ow� nazw� dnia tygodnia", s));
   }
 
   public String toString() {
     return dateSymbols.getWeekdays()[index];
   }
 
   public int toInt() {
     return index;
   }
 }
 
 ////////////////////////////////////////
 
 package org.jfree.date;
 
 public enum DateInterval {
   OPEN {
     public boolean isIn(int d, int left, int right) {
       return d > left && d < right;
     }
   },
   CLOSED_LEFT {
     public boolean isIn(int d, int left, int right) {
       return d >= left && d < right;
     }
   },
   CLOSED_RIGHT {
     public boolean isIn(int d, int left, int right) {
       return d > left && d <= right;
     }
   },
   CLOSED {
     public boolean isIn(int d, int left, int right) {
       return d >= left && d <= right;
     }
   };
 
   public abstract boolean isIn(int d, int left, int right);
 }
 
 //////////////////////////////////////////
 
 package org.jfree.date;
 
 public enum WeekInMonth {
   FIRST(1), SECOND(2), THIRD(3), FOURTH(4), LAST(0);
   private final int index;
   
   WeekInMonth(int index) {
     this.index = index;
   }
 
   public int toInt() {
     return index;
   }
 }
 
 //////////////////////////////////////////
 
 package org.jfree.date;
 
 public enum WeekdayRange {
   LAST, NEAREST, NEXT
 }
 
 /////////////////////////////////////////
 
 package org.jfree.date;
 
 import java.text.DateFormatSymbols;
 
 public class DateUtil {
   private static DateFormatSymbols dateFormatSymbols = new DateFormatSymbols();
   
   public static String[] getMonthNames() {
     return dateFormatSymbols.getMonths();
   }
 
   public static boolean isLeapYear(int year) {
     boolean fourth = year % 4 == 0;
     boolean hundredth = year % 100 == 0;
     boolean fourHundredth = year % 400 == 0;
     return fourth && (!hundredth || fourHundredth);
   }
 
   public static int lastDayOfMonth(Month month, int year) {
     if (month == Month.FEBRUARY && isLeapYear(year))
       return month.lastDay() + 1;
     else
       return month.lastDay();
   }
 
   public static int leapYearCount(int year) {
     int leap4 = (year - 1896) / 4;
     int leap100 = (year - 1800) / 100;
     int leap400 = (year - 1600) / 400;
     return leap4 - leap100 + leap400;
   }
 }
 
 //////////////////////////////////////////
 
 package org.jfree.date;
 
 public abstract class DayDateFactory {
   private static DayDateFactory factory = new SpreadsheetDateFactory();
   public static void setInstance(DayDateFactory factory) {
     DayDateFactory.factory = factory;
   }
 
   protected abstract DayDate _makeDate(int ordinal);
   protected abstract DayDate _makeDate(int day, Month month, int year);
   protected abstract DayDate _makeDate(int day, int month, int year);
   protected abstract DayDate _makeDate(java.util.Date date);
   protected abstract int _getMinimumYear();
   protected abstract int _getMaximumYear();
 
   public static DayDate makeDate(int ordinal) {
     return factory._makeDate(ordinal);
   }
 
   public static DayDate makeDate(int day, Month month, int year) {
     return factory._makeDate(day, month, year);
   }
 
   public static DayDate makeDate(int day, int month, int year) {
     return factory._makeDate(day, month, year);
   }
 
   public static DayDate makeDate(java.util.Date date) {
     return factory._makeDate(date);
   }
 
   public static int getMinimumYear() {
     return factory._getMinimumYear();
   }
 
   public static int getMaximumYear() {
     return factory._getMaximumYear();
   }
 }
 
 /////////////////////////////////////////////
 
 package org.jfree.date;
 
 import java.util.*;
 
 public class SpreadsheetDateFactory extends DayDateFactory {
   public DayDate _makeDate(int ordinal) {
     return new SpreadsheetDate(ordinal);
   }
 
   public DayDate _makeDate(int day, Month month, int year) {
     return new SpreadsheetDate(day, month, year);
   }
 
   public DayDate _makeDate(int day, int month, int year) {
     return new SpreadsheetDate(day, month, year);
   }
 
   public DayDate _makeDate(Date date) {
     final GregorianCalendar calendar = new GregorianCalendar();
     calendar.setTime(date);
     return new SpreadsheetDate(
       calendar.get(Calendar.DATE),
       Month.fromInt(calendar.get(Calendar.MONTH) + 1),
       calendar.get(Calendar.YEAR));
   }
 
   protected int _getMinimumYear() {
     return SpreadsheetDate.MINIMUM_YEAR_SUPPORTED;
   }
 
   protected int _getMaximumYear() {
     return SpreadsheetDate.MAXIMUM_YEAR_SUPPORTED;
   }
 }
 
 //////////////////////////////////////////////////
 
 /* ========================================================================
 * JCommon : a free general purpose class library for the Java(tm) platform
 * ========================================================================
 *
 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
 *
 ...
 *
 */
 
 package org.jfree.date;
 
 import static org.jfree.date.Month.FEBRUARY;
 
 import java.util.*;
 
 /**
  * Reprezentuje daty przy u�yciu liczb integer, podobnie jak w
  * programie Microsoft Excel. Obs�ugowany zakres dat to od
  * 1 stycznia 1900 do 31 grudnia 9999.
  * <p/>
  * Trzeba zwr�ci� uwag�. �e w Excelu wyst�puje b��d, powoduj�cy uznanie roku
  * 1900 za rok przest�pny, cho� nim nie jest. Wi�cej infromacji na ten temat
  * mo�na znale�� na witrynie Microsoft w artykule Q181370:
  * <p/>
  * http://support.microsoft.com/support/kb/articles/Q181/3/70.asp
  * <p/>
  * Excel korzysta z konwencji,w  kt�rej 1 stycznia 1900 = 1. Ta klasa korzysta
  * z konwencji w kt�rej 1 stycznia 1900 = 2.
  * W wyniku tego numer dnia w tej klasie jest inny ni� w
  * Excelu dla stycznia i lutego 1900... ale wtedy Excel wprowadza dodatkowy dzie�
  * (29 lutego 1900 kt�ry faktycznie nie istnia�!) i od tego momentu
  * numery dni zgadzaj� si�.
  *
  * @author David Gilbert
 */
 public class SpreadsheetDate extends DayDate {
   public static final int EARLIEST_DATE_ORDINAL = 2; // 1/1/1900
   public static final int LATEST_DATE_ORDINAL = 2958465; // 12/31/9999
   public static final int MINIMUM_YEAR_SUPPORTED = 1900;
   public static final int MAXIMUM_YEAR_SUPPORTED = 9999;
   static final int[] AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =
     {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
   static final int[] LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =
     {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
 
   private int ordinalDay;
   private int day;
   private Month month;
   private int year;
 
   public SpreadsheetDate(int day, Month month, int year) {
     if (year < MINIMUM_YEAR_SUPPORTED || year > MAXIMUM_YEAR_SUPPORTED)
       throw new IllegalArgumentException(
         "Argument 'year' musi zawiera� si� w zakresie " +
          MINIMUM_YEAR_SUPPORTED + " do " + MAXIMUM_YEAR_SUPPORTED + ".");
      if (day < 1 || day > DateUtil.lastDayOfMonth(month, year))
        throw new IllegalArgumentException("Nieprawid�owy argument 'day'.");
 
      this.year = year;
      this.month = month;
      this.day = day;
      ordinalDay = calcOrdinal(day, month, year);
      }
 
     public SpreadsheetDate(int day, int month, int year) {
       this(day, Month.fromInt(month), year);
     }
 
     public SpreadsheetDate(int serial) {
       if (serial < EARLIEST_DATE_ORDINAL || serial > LATEST_DATE_ORDINAL)
         throw new IllegalArgumentException(
           "SpreadsheetDate: warto�� 'serial' musi by� z zakresu od 2 do 2958465.");
 
       ordinalDay = serial;
       calcDayMonthYear();
    }
 
     public int getOrdinalDay() {
       return ordinalDay;
     }
 
     public int getYear() {
       return year;
     }
 
     public Month getMonth() {
       return month;
     }
 
     public int getDayOfMonth() {
       return day;
     }
 
     protected Day getDayOfWeekForOrdinalZero() {return Day.SATURDAY;}
 
     public boolean equals(Object object) {
       if (!(object instanceof DayDate))
         return false;
 
       DayDate date = (DayDate) object;
       return date.getOrdinalDay() == getOrdinalDay();
     }
 
     public int hashCode() {
       return getOrdinalDay();
     }
 
     public int compareTo(Object other) {
       return daysSince((DayDate) other);
     }
 
     private int calcOrdinal(int day, Month month, int year) {
       int leapDaysForYear = DateUtil.leapYearCount(year - 1);
       int daysUpToYear = (year - MINIMUM_YEAR_SUPPORTED) * 365 + leapDaysForYear;
       int daysUpToMonth = AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[month.toInt()];
       if (DateUtil.isLeapYear(year) && month.toInt() > FEBRUARY.toInt())
         daysUpToMonth++;
       int daysInMonth = day - 1;
       return daysUpToYear + daysUpToMonth + daysInMonth + EARLIEST_DATE_ORDINAL;
     }
 
     private void calcDayMonthYear() {
       int days = ordinalDay - EARLIEST_DATE_ORDINAL;
       int overestimatedYear = MINIMUM_YEAR_SUPPORTED + days / 365;
       int nonleapdays = days - DateUtil.leapYearCount(overestimatedYear);
       int underestimatedYear = MINIMUM_YEAR_SUPPORTED + nonleapdays / 365;
   
       year = huntForYearContaining(ordinalDay, underestimatedYear);
       int firstOrdinalOfYear = firstOrdinalOfYear(year);
       month = huntForMonthContaining(ordinalDay, firstOrdinalOfYear);
       day = ordinalDay - firstOrdinalOfYear - daysBeforeThisMonth(month.toInt());
     }
 
     private Month huntForMonthContaining(int anOrdinal, int firstOrdinalOfYear) {
       int daysIntoThisYear = anOrdinal - firstOrdinalOfYear;
       int aMonth = 1;
       while (daysBeforeThisMonth(aMonth) < daysIntoThisYear)
         aMonth++;
 
       return Month.fromInt(aMonth - 1);
     }
 
     private int daysBeforeThisMonth(int aMonth) {
       if (DateUtil.isLeapYear(year))
         return LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[aMonth] - 1;
       else
         return AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[aMonth] - 1;
     }
 
     private int huntForYearContaining(int anOrdinalDay, int startingYear) {
       int aYear = startingYear;
       while (firstOrdinalOfYear(aYear) <= anOrdinalDay)
         aYear++;
 
       return aYear - 1;
     }
 
     private int firstOrdinalOfYear(int year) {
       return calcOrdinal(1, Month.JANUARY, year);
     }
 
     public static DayDate createInstance(Date date) {
       GregorianCalendar calendar = new GregorianCalendar();
       calendar.setTime(date);
       return new SpreadsheetDate(calendar.get(Calendar.DATE),
                                  Month.fromInt(calendar.get(Calendar.MONTH) + 1),
                                  calendar.get(Calendar.YEAR));
 
     }
 }
 
 ///////////////////////////////////////////////////
 
 